---
authors: ["brice.dutheil"]
date: "2026-02-07T18:53:00+02:00"
language: en
tags: [ "jep-321", "java", "jvm", "httpclient", "okhttp" ]
slug: "ten-reasons-to-not-use-jdk-httpclient"
title: "10+ reasons to NOT use DK's HttpClient"
summary: This article explains in 10 reasons why after 14 JDK release the JDK's `HttpClient` introduced with Java 11 is unlikely to be the best option in your app.
---

The https://openjdk.org/jeps/321[JEP-321] has been delivered with JDK 11. It has been
https://openjdk.org/jeps/110[incubating since Java 9], it delivers a general purpose, standard HTTP client to be
used by every one.

CAUTION: When reading these lines keep in mind the following is based on facts, but keep in mind the whole article represent my opinion only.

This HTTP client is certainly most welcome when bootstrapping new code, basic use cases. Yet when it's time for more
control, "customization", robustness, the issues of the JDK HttpClient start showing:

* API Concepts are for basic usage but do not express well or even not at all more advanced ones, leaving the user
to fill in the gaps if that's possible

* It's not well battle tested; some issues fixed very late, some even in JDK 26, leave me worried compared
to other libraries.

* Customization affects the whole JVM, which is not ideal for libraries and may be a problem for whenever it is necessary to use different settings for different clients.


The reasons below may appeal to you or not depending on your mileage.
Also, the order is mine. Your opinion is most welcome.

TIP: Note that before there was an old private `sun.net.www.http.HttpClient` that used very specific purpose for the JDK.


== 10PLUS reasons

. Not possible to use a _named pipe_ or a _Unix Domain Socket_ (the `HttpClient` doesn't support passing a socket factory), even if UDS were added in JDK 16.

** https://bugs.openjdk.org/browse/JDK-8275838[JDK-8275838 java.net.http client does not work over unix domain sockets]
** https://bugs.openjdk.org/browse/JDK-8371218[JDK-8371218 Add Unix Domain Socket Support to jdk.httpserver]

. No request/response interceptors https://stackoverflow.com/questions/53707502/is-it-possible-to-intercept-java-11-httpclient-requests[Is it possible to intercept Java 11 HttpClient requests?]
+
Work around, wrap the client like this lib: https://github.com/raphw/interceptable-http-client

. `close`, `shutdown`, … methods were introduced in JDK 21

** https://bugs.openjdk.org/browse/JDK-8267140[JDK-8267140 Support closing the HttpClient by making it auto-closable]
** https://inside.java/2023/12/10/sip092/[`AutoCloseable` HttpClient - Sip of Java]

. No `URIBuilder`, relies on throwable URI class only, however, there are third party builders if needed

. Single timeout for a “call” i.e., both request and response. Also, the timeout timer is never checked before
and after response headers are received, possibly leaving the call hanging (https://bugs.openjdk.org/browse/JDK-8258397[JDK-8258397]), that means

** that a stalling upload can last way longer than the timeout, so the timeout may never fire.
** that a stalling download may also go way beyond the timeout.

. Keep alive for idle connections added in JDK 20; in particular, this allows closing idle connections
after this timeout expires. Before, idle connections were not closed. This can be tweaked via a system property (`jdk.httpclient.keepalive.timeout` and `jdk.httpclient.keepalive.timeout.h2`), which is JVM wide.
https://bugs.openjdk.org/browse/JDK-8295649[JDK-8295649 Add a means to close idle connections in the HTTP/2 connection pool]

. Higher “abstraction” level using Java’s usual API regarding SSL / TLS, with fewer customization points.

.. It’s not possible to customize the Socket Factory for SSL connections (just as regular HTTP connections).

.. Certificate pinning involves hardcoding a specific public key or certificate into your application to ensure it only communicates with trusted servers, preventing _man-in-the-middle_ attacks. JDK HttpClient requires creating full `TrustManager`, that perform the check, extracting keys from certificate, hash them, etc. It’s possible to use third party libs like https://github.com/Flowdalic/java-pinning[Flowdalic/java-pinning], but they may not cover other needs.

.. The JDK’s HttpClient do not allow customizing the hostname verification, It only allows to disable hostname verification JVM wide (`jdk.internal.httpclient.disableHostnameVerification`).

.. No connection fallback mechanism.

. No event listener to dive explore the behavior of HTTP calls from . This can be done by wrapping the HttpClient to measure a few things, but internal connection events are not available. Users of HttpClient are blind to DNS timing, connection timing, header and body timing. In

. HttpClient automatically retries to connect, it can be disabled by `jdk.httpclient.disableRetryConnect`. It’s limited to one retry. If it’s not a connection issue, `GET` and `HEAD` are retried by default, use `jdk.httpclient.enableAllMethodRetry` to change that.

. No API to control on the connection pool (which is mostly used for connection reuse), there’s a system property `jdk.httpclient.connectionPoolSize`. But no way to control parameters like _how long_ to keep it there until JDK 20 with system properties. Not closeable until JDK 21’s via `close` method.

. No concept of request "dispatch", these controls are internal to the http client. For async request it’s possible to pass a custom `Executor`, it’s up to you to write an executor that matches what you need.

. Request logging is done via a system property `jdk.httpclient.HttpClient.log`.


== Performance, bugs

. https://github.com/spring-projects/spring-framework/issues/22333[WebFlux with Java 11 HttpClient unexpected slow performance comparing with WebClient · Issue \#22333 · spring-projects/spring-framework]

. Connection Leak with HTTP/2 `GOAWAY` frame, which is used by a server to initiate a graceful shutdown of a connection

** https://bugs.openjdk.org/browse/JDK-8335181[JDK-8335181 Incorrect handling of HTTP/2 GOAWAY frames in HttpClient] (backported to 17.17, 21.0.8)

. HTTP/2 Stream count was not decreasing on 204 response code

** https://bugs.openjdk.org/browse/JDK-8238270[JDK-8238270 java.net HTTP/2 client does not decrease stream count when receives 204 response] (backported to 11.0.9)

. Request and response timeout disarms when response headers are received and didn't account for the full response body. Only Response timeout is fixed from JDK 26.

** https://bugs.openjdk.org/browse/JDK-8208693[JDK-8208693 HttpClient: Extend the request timeout's scope to cover the response body]
** https://bugs.openjdk.org/browse/JDK-8258397[JDK-8258397 HttpClient: Investigate supporting timeout for reading body bytes]

. HttpClient fails to close its side of the socket, leaving the connection in CLOSE_WAIT when it receives _EOF_ during response read
https://bugs.openjdk.org/browse/JDK-8221395[JDK-8221395 HttpClient leaving connections in CLOSE_WAIT state until the Java process ends], fixed in 11.0.6

. The logic to retry on connection was inverted until 11.0.6, which made it disabled by default

** https://bugs.openjdk.org/browse/JDK-8216561[JDK-8216561 HttpClient: The logic of retry on connect exception is inverted]

. When using a custom executor that rejects a task with `RejectedExecutionException`, it may shut down the internal `SelectorManager`, this affect both synchronous and asynchronous API (synchronous uses the async API under the hood), fixed in Java 19, backported to 17.0.17.

** https://bugs.openjdk.org/browse/JDK-8277969[JDK-8277969 HttpClient SelectorManager shuts down when custom Executor rejects a task]


