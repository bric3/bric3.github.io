<!DOCTYPE html>
<html lang="en">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.80.0" />

    
    
    

<title>HTTPS en Java avec un certificat auto-signé • Brice Dutheil</title>













    
<meta property="og:locale" content="en">
<meta property="og:site_name" content="Brice Dutheil">
<meta property="og:title" content="HTTPS en Java avec un certificat auto-signé">
<meta property="og:type" content="website">
<meta property="og:url" content="https://blog.arkey.fr/2017/10/19/self-signed-certificates-in-java/" />
<meta property="og:description" content="Java mostly, and general tech">
<meta property="og:image" content="https://blog.arkey.fr/social-sharing.png">
<meta property="og:image:type" content="image/png">
    
    
    
<meta property="og:image:width" content="192">
<meta property="og:image:height" content="192">
    

<meta property="og:updated_time" content="2017-10-19T00:00:00Z">



<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@BriceDutheil">
<meta name="twitter:title" content="HTTPS en Java avec un certificat auto-signé">

<meta name="twitter:image" content="https://blog.arkey.fr/social-sharing.png">

<meta name="twitter:description" content="Java mostly, and general tech">
<meta name="twitter:creator" content="@BriceDutheil">
    
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/styles/a11y-light.min.css" media="(prefers-color-scheme: light)"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/styles/gruvbox-dark.min.css" media="(prefers-color-scheme: dark)">




<link rel="stylesheet" href="/scss/hyde-hyde.dd81e7ab42051dce4af5e995f71cc9ffa0a9d977c7fa252fbf1cfea75d1d463b.css" integrity="sha256-3YHnq0IFHc5K9emV9xzJ/6Cp2XfH&#43;iUvvxz&#43;p10dRjs=">


<link rel="stylesheet" href="/scss/hyde-hyde-dark.8dcf235ba9845159df4d1ea26547422f22737b721fb3bb5a9d1b7ecec0f09be8.css" integrity="sha256-jc8jW6mEUVnfTR6iZUdCLyJze3Ifs7tanRt&#43;zsDwm&#43;g=" media="(prefers-color-scheme: dark)">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    
    <link rel="shortcut icon" sizes="192x192" href="/android-192-favicon.png">

    
    <link rel="shortcut icon" href="/android-192-favicon.png">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/v4-shims.min.css" integrity="sha512-KNosrY5jkv7dI1q54vqk0N3x1xEmEn4sjzpU1lWL6bv5VVddcYKQVhHV08468FK6eBBSXTwGlMMZLPTXSpHYHA==" crossorigin="anonymous" />

    
    


    
</head>


    <body class="">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://blog.arkey.fr">Brice Dutheil</a>
      </span>
      
      
        <div class="author-image">
          <img src="https://www.gravatar.com/avatar/f31c7fbcbb0766d0632d96fd7e74b649?s=240&d=mp" class="img--circle img--headshot element--center" alt="gravatar">
        </div>
      
      <p class="site__description">
         Java mostly, and general tech 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">Brice Dutheil</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/"><span class='fa-icon'><i class='fas fa-home'></i></span><code>cd <em>~</em></code>
						<span></span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/posts/"><span class='fa-icon'><i class='fas fa-stream'></i></span><code>ls <em>posts/*</em></code>
						<span></span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/series/"><span class='fa-icon'><i class='fas fa-list-alt'></i></span><code>grep -o <em>series</em> posts/* | sort -u</code>
						<span></span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/tags/"><span class='fa-icon'><i class='fas fa-tags'></i></span><code>grep -o <em>tags</em> posts/* | sort -u</code>
						<span></span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/cool-stuff/"><span class='fa-icon'><i class='fas fa-thumbtack'></i></span><code>cd <em>cool-stuff</em></code>
						<span></span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/whoami/"><span class='fa-icon'><i class='fas fa-id-card'></i></span><code>whoami</code>
						<span></span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	<a href="https://twitter.com/BriceDutheil" rel="me"><i class="fa-w-16" aria-hidden="true"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="bird" class="svg-inline--fa fa-bird fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></i></a>
	
	
	
	<a href="https://github.com/bric3" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	<a href="https://speakerdeck.com/bric3" rel="me"><i class="fab fa-speaker-deck" aria-hidden="true"></i></i></a>
	
	
	
	
	
	
	
	<a href="https://linkedin.com/in/dutheilbrice" rel="me"><i class="fa-w-16" aria-hidden="true"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="pro-network" class="svg-inline--fa fa-pro-network fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></i></a>
	
	
	<a href="https://stackoverflow.com/users/48136/brice" rel="me"><i class="fab fa-stack-overflow fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
</section>

      </div>
    </div>

  </div>
  <div class="container fixed-container">
    
<div class="copyright">
  &copy; 2010 - 2021 Brice Dutheil
  
    <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
  
</div>



  </div>
</div>

        <div class="content container">
            
    <header>

 
 
 <div class="github-edit">
     <a href="https://github.com/bric3/bric3.github.io/edit/hugo-sources/content/posts/2017-10-19-self-signed-certificates-in-java.md">
     <i class="fab fa-github fa-lg" aria-hidden="true"></i> Edit this page
     </a>
 </div>
 


</header>

            
    

<article>
  <header>
    <h1>HTTPS en Java avec un certificat auto-signé</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> 2017-10-19
    
    
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/ssl">ssl</a>
           
      
          <a class="badge badge-tag" href="/tags/tls">tls</a>
           
      
          <a class="badge badge-tag" href="/tags/https">https</a>
           
      
          <a class="badge badge-tag" href="/tags/java">java</a>
           
      
          <a class="badge badge-tag" href="/tags/okhttp">okhttp</a>
           
      
          <a class="badge badge-tag" href="/tags/openssl">openssl</a>
           
      
          <a class="badge badge-tag" href="/tags/trustmanager">trustmanager</a>
           
      
          <a class="badge badge-tag" href="/tags/certificate-authority">certificate authority</a>
           
      
          <a class="badge badge-tag" href="/tags/self-signed-certificate">self-signed certificate</a>
           
      
          <a class="badge badge-tag" href="/tags/certificat-auto-signe">certificat auto-signé</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 68 min read

    
    
    

</div>


  </header>
  
  
  
  <div class="post md">
    <p>Votre application doit se connecter à un serveur HTTPS, normalement pas de problème,<br>
en craftman on se dit qu&rsquo;il faudrait écrire des tests unitaires afin de s&rsquo;assurer
que le code fonctionne avec des URI HTTPS.</p>
<p>Le code suivant utilise <strong>wiremock</strong>, ce test va juste vérifier que le
client se connecte sans problème sur le port HTTPS de wiremock.</p>
<pre><code class="language-java">public class WireMockSSLTest {
    @Rule
    public WireMockRule wireMock = new WireMockRule(wireMockConfig().dynamicPort()
                                                                    .dynamicHttpsPort());

    @Test
    public void ssl_poke() throws IOException {
        new OkHttpClient.Builder().build()
                                  .newCall(new Request.Builder().get()
                                                                .url(&quot;https://localhost:&quot; 
                                                                     + wireMock.httpsPort())
                                                                .build())
                                  .execute();
    }
}
</code></pre>
<p>À l&rsquo;exécution ce code lève l&rsquo;exception suivante:</p>
<pre><code>javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at ...
Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at ...
	... 10 more
Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at ...
	... 16 more
</code></pre>
<p>C&rsquo;est impressionnant au premier abord, on y voit des acronymes qui font peur (PKIX)
des packages <code>sun</code>. Alors que dit cette stacktrace :</p>
<ul>
<li><code>SSLHandshakeException</code> : il s&rsquo;agit d&rsquo;une erreur de négociation SSL</li>
<li><code>ValidatorException: PKIX path building failed</code> : le client n&rsquo;arrive pas à
construire la <em>chaine</em> des certificats en suivant la norme <strong>PKIX</strong></li>
</ul>
<p>Autrement dit, ce serveur (wiremock) expose un certificat, mais le client n&rsquo;arrive
pas à remonter la chaine des certificats jusqu&rsquo;à une <strong>autorité</strong> connue pour le
vérifier. Pourquoi cette exception? Le même code qui se connecte sur <code>https://google.com</code>
fonctionnera sans cette erreur. Le soucis vient du fait que wiremock utilise un
<strong>certificat auto-signé</strong>, et ce certificat auto-signé n&rsquo;est pas reconnu comme valide
par les réglages par défaut de la JVM.</p>
<p>Dans cet article, nous allons voir les différentes approches pour gérer un
<strong>certificat auto-signé</strong>, et explorer les moyens de contrôler quel certificat est
utilisé dans son environnement de test en générant soi même son certificat auto-signé.</p>
<h2 id="bref-rappel-sur-ssl-enfin-plutôt-tls-">Bref rappel sur SSL, enfin plutôt TLS ?</h2>
<p>Quand on parle de <em>SSL</em> aujourd&rsquo;hui, on fait l&rsquo;amalgame de deux protocoles, de TLS et
de son prédécesseur SSL.</p>
<ul>
<li>SSL est l&rsquo;acronyme de <strong>S</strong>ecure <strong>S</strong>ockets <strong>L</strong>ayer, ce protocole a été développé
par <strong>Netscape</strong> (pour ceux qui se rappellent du navigateur concurrent de Internet
Explorer).
La dernière version SSLv3 est considérée comme dépréciée depuis 2015.</li>
<li>TLS est l&rsquo;acronyme de <strong>T</strong>ransport <strong>L</strong>ayer <strong>S</strong>ecurity, ce protocole est le
successeur direct du protocole SSLv3 mais ils sont cependant incompatible entre eux.</li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">[source]</a></p>
<p>Ce que fait TLS c&rsquo;est de s&rsquo;assurer que le communication entre deux peer soit sécurisée.
TLS <a href="https://tools.ietf.org/html/rfc5246#section-7">s&rsquo;appuis notamment sur <strong>PKIX</strong></a>
(<a href="https://tools.ietf.org/html/rfc5280"><strong>P</strong>ublic <strong>K</strong>ey <strong>I</strong>nfrastrcture <strong>X</strong>.509</a>)
et que l&rsquo;identité du serveur est bien celui qu&rsquo;il prétend être (grâce à son certificat)
et à celui d&rsquo;un tiers de confiance. En général il s&rsquo;agit d&rsquo;une chaine de confiance.</p>
<p>Par exemple :</p>
<blockquote>
<p>À la connexion sur <a href="https://github.com">https://github.com</a>, en premier il faut vérifier le certificat
de GitHub, regarder qui a signé ce certificat, vérifier le certificat du signataire
et ainsi de suite jusqu&rsquo;à finir sur un certificat d&rsquo;un tiers de confiance, en
général ce dernier certificat est celui d&rsquo;une autorité de certification.</p>
</blockquote>
<p>Ces certificats appelés certificats <strong>X.509</strong> portent des informations comme le
nom du serveur, le nom du signataire, la signature, etc.</p>
<p>Un certificat peut-être sauvé dans un fichier encodé soit au format binaire <code>DER</code>
soit encodé au format US-ASCII <code>PEM</code>.</p>
<blockquote>
<p>À noter l&rsquo;extension <code>CRT</code> correspond bien à un certificat qu&rsquo;il soit encodé au format
<code>DER</code> ou au format <code>PEM</code>. L&rsquo;extension <code>CER</code> est une forme alternative de microsoft.</p>
</blockquote>
<h2 id="fixer-le-code-pour-que-le-test-passe">Fixer le code pour que le test passe</h2>
<h3 id="faire-confiance-à-tout-le-monde">Faire confiance à tout le monde</h3>
<p>Pour accepter ce certificat auto-signé, il est possible de configurer la
socket SSL pour accepter tous les certificats.</p>
<pre><code class="language-java">@Rule
public WireMockRule wireMock = new WireMockRule(wireMockConfig().dynamicPort()
                                                                .dynamicHttpsPort());

@Test
public void ssl_poke() throws IOException {
    X509TrustManager trustManager = TrustAllX509TrustManager.INSTANCE;
    OkHttpClient client = new OkHttpClient.Builder()
            .sslSocketFactory(
                    sslContext(null,
                                new TrustManager[]{trustManager}).getSocketFactory(),
                    trustManager)
            .build();
    try (Response r = client.newCall(new Request.Builder().get()
                                                          .url(&quot;https://localhost:&quot;
                                                               + wireMock.httpsPort())
                                                          .build())
                            .execute()) {
        // noop / success
    }
}
</code></pre>
<p>OkHttp prend en paramètre une factory de socket SSL, ce contexte SSL devra être
initialisé avec un gestionnaire de confiance personnalisé pour accepter
n&rsquo;importe quel certificat. Pour fluidifier la lecture du code la création du
contexte SSL est faite à part.</p>
<pre><code class="language-java">public static SSLContext sslContext(KeyManager[] keyManagers, TrustManager[] trustManagers) {
    try {
        SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);
        sslContext.init(keyManagers,
                        trustManagers,
                        null);
        return sslContext;
    } catch (NoSuchAlgorithmException | KeyManagementException e) {
        throw new IllegalStateException(&quot;Couldn't init TLS context&quot;, e);
    }
}
</code></pre>
<p>Le l&rsquo;architecture du code de cryptographie en Java est très générique,
ce qui soulève certaines questions sur ces APIs, par exemple pourquoi la méthode
<code>SSLContext#init</code> force l&rsquo;utilisation de tableaux.
Dans ce cas précis la javadoc de la méthode <a href="https://docs.oracle.com/javase/8/docs/api/javax/net/ssl/SSLContext.html#init-javax.net.ssl.KeyManager:A-javax.net.ssl.TrustManager:A-java.security.SecureRandom-"><code>SSLContext#init</code></a>
indique que seul le premier élément du tableau sera utilisé, pour cette raison
le code plus haut passe un tableau d&rsquo;un seul élément.</p>
<blockquote>
<pre><code>javax.net.ssl.SSLContext
public final void init(KeyManager[] km,
                      TrustManager[] tm,
                      SecureRandom random)
               throws KeyManagementException

Initializes this context. Either of the first two parameters may be null in which 
case the installed security providers will be searched for the highest priority 
implementation of the appropriate factory. Likewise, the secure random parameter 
may be null in which case the default implementation will be used.

**Only the first instance** of a particular key and/or trust manager implementation 
type in the array is used. (For example, only the first javax.net.ssl.X509KeyManager 
in the array will be used.)

Parameters:
    km - the sources of authentication keys or null
    tm - the sources of peer authentication trust decisions or null
    random - the source of randomness for this generator or null
Throws:
   KeyManagementException - if this operation fails
</code></pre>
</blockquote>
<p>L&rsquo;interface <code>TrustManager</code> est une interface vide, mais étant donné qu&rsquo;il s&rsquo;agit
d&rsquo;un gestionnaire de confiance pour TLS, et que la spécification est uniquement
basé sur PKIX (X.509), la seule implémentation sera du type <code>X509TrustManager</code>,
interface qui défini les méthodes nécessaires pour procéder à la vérification
des certificats.</p>
<p>Pour cette approche le gestionnaire de confiance acceptera tous les certificats,
il ne procède à aucune vérification de la chaine de certificats.</p>
<pre><code class="language-java">public static class TrustAllX509TrustManager implements X509TrustManager {
    public static final X509TrustManager INSTANCE = new TrustAllX509TrustManager();

    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType) 
    throws CertificateException { }

    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType) 
    throws CertificateException { }

    @Override
    public X509Certificate[] getAcceptedIssuers() {
        return new X509Certificate[0];
    }
}
</code></pre>
<p>Avec ça le code est censé fonctionner, mais il y a toujours une erreur lors de
l&rsquo;accès à notre serveur wiremock :</p>
<pre><code>javax.net.ssl.SSLPeerUnverifiedException: Hostname localhost not verified:
    certificate: sha256//W3v5TDAEE3dl4peiEwpwDKa1OZAna1ITgokQDz0rkQ=
    DN: CN=Tom Akehurst, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown
    subjectAltNames: []

	at okhttp3.internal.connection.RealConnection.connectTls(RealConnection.java:308)
	...
</code></pre>
<p>En effet, le code du dessus adresse la question de confiance pour la <em>couche</em> TLS.
Mais en HTTPS, tous les client doivent en fait vérifier l&rsquo;identité du serveur avec
le hostname (<a href="https://tools.ietf.org/html/rfc2818#section-3.1">RFC 2818</a>) ceci
afin de prévenir les attaques <em>man-in-the-middle</em>.</p>
<p>Dans ce cas précis le certificat auto-signé de wiremock ne fournit pas de noms
alternatifs <code>subjectAltNames</code> qui correspondent soit à <code>localhost</code> soit aux IPs
locales.</p>
<p>Il est possible d&rsquo;écrire un <code>HostnameVerifier</code> qui accepte tous les hostnames :</p>
<pre><code class="language-java">public static HostnameVerifier allowAllHostNames() {
    return (hostname, sslSession) -&gt; true;
}
</code></pre>
<pre><code class="language-java">new OkHttpClient.Builder()
            .sslSocketFactory(
                    sslContext(null, 
                               new TrustManager[] {TrustAllX509TrustManager.INSTANCE}).getSocketFactory(),
                    TrustAllX509TrustManager.INSTANCE)
            .hostnameVerifier(allowAllHostNames())
            .build()
            .newCall(new Request.Builder().get()
                                          .url(&quot;https://localhost:&quot; + wireMock.httpsPort())
                                          .build())
            .execute();
</code></pre>
<p>Ce code fonctionnera, il est maintenant possible de se connecter à wiremock en HTTPS.</p>
<p>En revanche, cette configuration ne doit pas être utilisée sur du code de production,
car ce la revient à désactiver la sécurité sur toutes les connections SSL.
Il faudra donc prévoir un mécanisme de configuration de connexion SSL dans le
code de production pour conserver des réglages sains en production et relaxer
la sécurité pour le serveur de test.</p>
<p>À noter par exemple que cet exemple est pensé pour du back-end, mais ce sujet
touche de près les applications mobiles. Par exemple la
<a href="https://developer.android.com/training/articles/security-ssl.html#CommonHostnameProbs">documentation Android</a>
explique très bien les soucis liés à la vérification du hostname.</p>
<h4 id="vanilla-java">Vanilla Java</h4>
<p>Pour ceux que ça intéresse le code équivalent en configurant <code>HttpsUrlConnection</code> :</p>
<pre><code class="language-java">// Autorise tous les certificats
HttpsURLConnection.setDefaultSSLSocketFactory(trustAllSslContext().getSocketFactory());
new URL(&quot;https://localhost:&quot; + wireMock.httpsPort()).openConnection().connect();
</code></pre>
<p>Il faut ajouter un <a href="https://docs.oracle.com/javase/8/docs/api/javax/net/ssl/HostnameVerifier.html"><code>HostnameVerifier</code></a>
qui ne vérifie rien, et de configurer <code>HttpsURLConnection</code> avant d&rsquo;établir la connexion :</p>
<pre><code class="language-java">HostnameVerifier allHostsValid = (hostname, session) -&gt; true;
HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
HttpsURLConnection.setDefaultSSLSocketFactory(trustAllSslContext().getSocketFactory());
new URL(&quot;https://localhost:&quot; + wireMock.httpsPort()).openConnection().connect();
</code></pre>
<h3 id="faire-confiance-aux-certificats-auto-signés">Faire confiance aux certificats auto-signés</h3>
<p>Plutôt que d'<em>éteindre</em> la sécurité, une approche plus fine serait de désactiver
la vérification uniquement pour un certificat auto-signé. Mais comment sait-on
identifier un certificat auto-signé ?</p>
<p>En se connectant avec OpenSSL sur le serveur HTTPS wiremock avec la sous-commande
<code>s_client</code> qui fait office de client SSL/TLS.</p>
<pre><code class="language-sh">echo -n | openssl s_client -connect localhost:8443 2&gt;&amp;1
</code></pre>
<p>Cette commande donne en retour plein de donnée intéressantes :</p>
<pre><code>CONNECTED(00000003)
depth=0 C = Unknown, ST = Unknown, L = Unknown, O = Unknown, OU = Unknown, CN = Tom Akehurst
verify error:num=18:self signed certificate
verify return:1
depth=0 C = Unknown, ST = Unknown, L = Unknown, O = Unknown, OU = Unknown, CN = Tom Akehurst
verify return:1
---
Certificate chain
 0 s:/C=Unknown/ST=Unknown/L=Unknown/O=Unknown/OU=Unknown/CN=Tom Akehurst
   i:/C=Unknown/ST=Unknown/L=Unknown/O=Unknown/OU=Unknown/CN=Tom Akehurst
---
Server certificate
-----BEGIN CERTIFICATE-----
MIIDgzCCAmugAwIBAgIEHYkuTzANBgkqhkiG9w0BAQsFADBxMRAwDgYDVQQGEwdV
bmtub3duMRAwDgYDVQQIEwdVbmtub3duMRAwDgYDVQQHEwdVbmtub3duMRAwDgYD
VQQKEwdVbmtub3duMRAwDgYDVQQLEwdVbmtub3duMRUwEwYDVQQDEwxUb20gQWtl
aHVyc3QwIBcNMTUwMjI0MTM1ODUwWhgPMjExNTAxMzExMzU4NTBaMHExEDAOBgNV
BAYTB1Vua25vd24xEDAOBgNVBAgTB1Vua25vd24xEDAOBgNVBAcTB1Vua25vd24x
EDAOBgNVBAoTB1Vua25vd24xEDAOBgNVBAsTB1Vua25vd24xFTATBgNVBAMTDFRv
bSBBa2VodXJzdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAIAIvMUo
vy4ufnWKxMU0tBdXqtX6RzKYgQvj/82qPAmRiNki8PpPGrF70Lb3WzsUDYB9CsXw
m5VWc9l1XBdGh6zZVFkkSzBtRjyHy8Z8azsIv/YzQF5bRxE2Cvruh7o01Sq1qz5B
kxt0u/NbUUErxKZeA0li1W/op7RC94h0dzob7auruHUvb56NXAJZcu8r2G9jxh9w
WBPC6lSozuCzwfdS4v2ZOQBYpmMz9oJm3ElQUbOrhnVQtgxQicU2oDETwz37IIEw
FV12la+qNIMSOTe6uJj1jEZP22NL2IYq06BT/ZnK6HYIOXAtwURSsf0MN0b8NKBB
NOLQN2juRj+vn6UCAwEAAaMhMB8wHQYDVR0OBBYEFDZ6soXRxD/N2n5b++CVrWbr
XLKWMA0GCSqGSIb3DQEBCwUAA4IBAQBiPfCUg7EHz8poRgZL60PzMdyaKLwafGtF
dshmY1y9vzpPJIoFcIH7crSsmUcRk+XSj5WhSr4RT3y15JsfZy935057f0knEXEf
or+Gi8BlDaC33qX+6twiAaub1inEDc028ZFtEwbzJQYgJo1GvLG2o2BMZB1C5F+k
Nm9jawu4rTNtXktXloNhoxrSWtyEUoDAvGgBVnAJwQXcfayWq3AsCr9kpHI3bBwL
J9NAGC4M8j7z9Aw71JGmwBDk1ooAO6L82W7DWBYPzpLXXeXmHRCxpujKWaveAV2T
cgsQaCmzy29i+F03pLl7Vio4Ei+z9XQgZiN4Awiwz9D+lshnKuII
-----END CERTIFICATE-----
subject=/C=Unknown/ST=Unknown/L=Unknown/O=Unknown/OU=Unknown/CN=Tom Akehurst
issuer=/C=Unknown/ST=Unknown/L=Unknown/O=Unknown/OU=Unknown/CN=Tom Akehurst
---
No client certificate CA names sent
Peer signing digest: SHA512
Server Temp Key: ECDH, P-256, 256 bits
---
SSL handshake has read 1387 bytes and written 434 bytes
---
New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES128-GCM-SHA256
Server public key is 2048 bit
Secure Renegotiation IS supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : ECDHE-RSA-AES128-GCM-SHA256
    Session-ID: 59D642ED8CCB7F4219617B3739CB93E1C294F873854C2A284D28A77D674AC050
    Session-ID-ctx: 
    Master-Key: A43DF026E3FA620BC7CC5207D5BCB87828B7E3D673CFEEF12CAB425619B63610F443FB96FEC33CC50FBBAC73C152572B
    Key-Arg   : None
    PSK identity: None
    PSK identity hint: None
    SRP username: None
    Start Time: 1507214061
    Timeout   : 300 (sec)
    Verify return code: 18 (self signed certificate)
---
DONE
</code></pre>
<p>Typiquement :</p>
<pre><code>depth=0 C = Unknown, ST = Unknown, L = Unknown, O = Unknown, OU = Unknown, CN = Tom Akehurst
verify error:num=18:self signed certificate
</code></pre>
<p>La vérification du certificat indique le code <code>18</code> et indique qu&rsquo;il s&rsquo;agit d&rsquo;un
certificat auto-signé. Plus précisément le <a href="https://wiki.openssl.org/index.php/Manual:Verify(1)">wiki openssl</a>
indique :</p>
<blockquote>
<p><strong>18 X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT</strong>: self signed certificate</p>
</blockquote>
<p>Donc une chaine avec une profondeur de <code>0</code> correspond en fait à un certificat non-signé</p>
<p>Il y a aussi la chaine de certificat elle même avec, pour chaque certificat, la
première ligne <strong><code>s</code></strong> qui indique le <em>sujet</em> du certificat, et une deuxième
ligne <strong><code>i</code></strong> qui indique l'<em>issuer</em> du certificat. Le chiffre indique la <em>profondeur</em>
du certificat.</p>
<pre><code>Certificate chain
 0 s:/C=Unknown/ST=Unknown/L=Unknown/O=Unknown/OU=Unknown/CN=Tom Akehurst
   i:/C=Unknown/ST=Unknown/L=Unknown/O=Unknown/OU=Unknown/CN=Tom Akehurst
</code></pre>
<p>Ce que ça veut dire c&rsquo;est qu&rsquo;il est possible d&rsquo;écrire un trust manager capable
de vérifier les chaines de certificats usuelles et de détecter les certificats
auto-signés pour leur appliquer une vérification spécifique.</p>
<pre><code class="language-java">public static class TrustSelfSignedX509TrustManager implements X509TrustManager {
    private X509TrustManager delegate;

    private TrustSelfSignedX509TrustManager(X509TrustManager delegate) {
        this.delegate = delegate;
    }

    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        delegate.checkClientTrusted(chain, authType);
    }

    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        if (isSelfSigned(chain)) {
            return;
        }
        delegate.checkServerTrusted(chain, authType);
    }

    private boolean isSelfSigned(X509Certificate[] chain) {
        return chain.length == 1;
    }

    @Override
    public X509Certificate[] getAcceptedIssuers() {
        return delegate.getAcceptedIssuers();
    }

    public static X509TrustManager[] wrap(X509TrustManager delegate) {
        return new X509TrustManager[]{new TrustSelfSignedX509TrustManager(delegate)};
    }
}
</code></pre>
<p>Ce code <em>décore</em> un trust manager existant en ajoutant un comportement spécifique
pour les certificats auto-signés.</p>
<p>Il s&rsquo;utilisera de la manière suivante en décorant le gestionnaire de confiance par défaut de la JVM :</p>
<pre><code class="language-java">X509TrustManager trustManager = TrustSelfSignedX509TrustManager.wrap(systemTrustManager());
new OkHttpClient.Builder()
            .sslSocketFactory(
                    sslContext(null, 
                               new TrustManager[] { trustManager }).getSocketFactory(),
                    trustManager)
            .hostnameVerifier(allowAllHostname())
            .build()
            .newCall(new Request.Builder().get()
                                          .url(&quot;https://localhost:&quot; + wireMock.httpsPort())
                                          .build())
            .execute();
</code></pre>
<p>On accède au gestionnaire par défaut avec ce code.</p>
<pre><code class="language-java">public static X509TrustManager systemTrustManager() {
    TrustManager[] trustManagers = systemTrustManagerFactory().getTrustManagers();
    if (trustManagers.length != 1) {
        throw new IllegalStateException(&quot;Unexpected default trust managers:&quot;
                                        + Arrays.toString(trustManagers));
    }
    TrustManager trustManager = trustManagers[0];
    if (trustManager instanceof X509TrustManager) {
        return (X509TrustManager) trustManager;
    }
    throw new IllegalStateException(&quot;'&quot; + trustManager + &quot;' is not a X509TrustManager&quot;);
}


private static TrustManagerFactory systemTrustManagerFactory() {
    try {
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmf.init((KeyStore) null);
        return tmf;
    } catch (NoSuchAlgorithmException | KeyStoreException e) {
        throw new IllegalStateException(&quot;Can't load default trust manager&quot;, e);
    }
}
</code></pre>
<p><code>TrustManagerFactory.getDefaultAlgorithm()</code> ne renverra que <code>PKIX</code> car c&rsquo;est le
seul algorithme utilisé par SSL. Toutefois des <em>algorithmes</em> spécifiques peuvent
être chargées, comme par exemple sur une JVM Sun/Oracle <code>SunX509</code> (ce qui ne sera bien
évidement pas disponible sur IBM J9 ou sur Android. En revanche ces implémentations
sont toutes du type <code>X509TrustManager</code>.</p>
<p>À noter aussi le coté très générique cette API fait que <code>TrustManager.getTrustManagers()</code>
renvoie un tableau de <code>TrustManager</code> pour chaque <em>type</em> de gestion de confiance.
La javadoc:</p>
<blockquote>
<pre><code>public final TrustManager[] getTrustManagers()

Returns one trust manager for each type of trust material.

Returns:
    the trust managers
Throws:
    IllegalStateException - if the factory is not initialized.
</code></pre>
</blockquote>
<p>Dans les faits jusqu&rsquo;à aujourd&rsquo;hui PKIX / X509 est le seul type possible pour une
connexion TLS. Et la factory de la JVM ne crée qu&rsquo;une seule instance de trust
manager de type <code>X509Trustmanager</code>.</p>
<p>Bien que cela fonctionne et que la sécurité ait été raffinée la sécurité est
toujours désactivée pour les certificats auto-signés. C&rsquo;est acceptable pour
du test mais si le code de production doit parler à des serveurs dont le
certificat est auto-signé alors il est crucial de vérifier ce certificat
pour accorder la confiance au tiers.</p>
<p>À noter que ce code peut-être étendu pour aller plus loin dans la vérification
du certificat auto-signé.</p>
<pre><code class="language-java">if (isSelfSigned(chain)) {
    verifyMoreStuff(chain);
}
</code></pre>
<h2 id="comment-vérifier-proprement-des-certificats-auto-signés-">Comment vérifier proprement des certificats auto-signés ?</h2>
<p>Que faire si le code de production doit faire confiance à un serveur dont le
certificat est auto-signé ?</p>
<p>Dans le cas d&rsquo;un certificat auto-signé, la JVM n&rsquo;est pas capable d&rsquo;accorder
de la confiance à ce certificat parce que aucune autorité de certification
(les <em>CA</em>) n&rsquo;a signé / émis ce dit certificat. Pour remédier à ça il faut
<em>installer</em> ce certificat.</p>
<p>Avant de l&rsquo;installer toutefois, il faut le récupérer.</p>
<h3 id="récupération-du-certificat-auto-signé">Récupération du certificat auto-signé</h3>
<p>À l&rsquo;établissement de la connexion TLS, plus précisément durant la phase de
négociation, le serveur envoie ses certificats.</p>
<p>Il est possible de les récupérer au format <code>PEM</code> avec <code>openssl</code>.</p>
<pre><code class="language-sh">echo -n | \
  openssl s_client -prexit -connect host:port 2&gt;&amp;1 | \
  openssl x509 -outform pem \
  &gt; certificate-host.pem
</code></pre>
<p>On indique au client ssl de <code>openssl</code> d&rsquo;établir la connexion sur <code>host:port</code>
puis le résultat est passé à la commande <code>x509</code> pour décoder le certificat
(à la norme x509) afin de l&rsquo;extraire sous la forme du format PEM.</p>
<p>On peut également afficher dans la console une représentation lisible par
les humains :</p>
<pre><code class="language-sh">echo -n | \
  openssl s_client -connect host:port 2&gt;&amp;1 | \
  openssl x509 -text
</code></pre>
<p>Pour lire le contenu du certificat stocké au format PEM on peut soit utiliser <code>openssl</code>
soit <code>keytool</code> l&rsquo;outils de la JVM.</p>
<pre><code class="language-sh">keytool -printcert -file certificate-host.pem
openssl x509 -inform pem -in certificate-host.pem -text
</code></pre>
<h3 id="utilisation-du-certificat-autosigné-sur-la-jvm">Utilisation du certificat autosigné sur la JVM</h3>
<h4 id="en-installant-le-certificat-dans-le-_cacerts_-de-la-jvm">En installant le certificat dans le <em>cacerts</em> de la JVM</h4>
<p>La JVM vient avec un fichier <code>cacerts</code> qui représente les <em>certificats des autorités
de certification</em>. Un certificat auto-signé n&rsquo;a pas été signé (émis) par une de
ces autorités, mais étant donné qu&rsquo;il se signe lui-même, il est possible de
l&rsquo;installer dans ce keystore <code>cacerts</code>. Cela se fait avec l&rsquo;outil <code>keytool</code> ; en
fonction des permissions il faudra passer cette commande avec <code>sudo</code>. Le mot
de passe par défaut du keystore de la JVM est <code>changeit</code>.</p>
<pre><code class="language-sh">keytool -import \
        -alias wiremock \
        -file wiremock.pem \
        -keystore $JAVA_HOME/jre/lib/security/cacerts
</code></pre>
<p>Au préalable le certificat <code>wiremock.pem</code> (au format <strong>PEM</strong> donc) a été extrait
d&rsquo;un serveur wiremock. Cette commande l&rsquo;importera avec l&rsquo;alias <code>wiremock</code> dans
le <em>keystore</em> <code>cacerts</code> (fichier du JRE).</p>
<blockquote>
<p>Il également est possible de regarder le contenu du store <code>cacerts</code> :</p>
<pre><code class="language-sh">keytool -list -keystore $JAVA_HOME/jre/lib/security/cacerts
</code></pre>
<p>Après on importation on y retrouvera le certificat <code>wiremock</code> à coté de
ceux de Verisign, Digital Certs, Geo Trust, etc.</p>
</blockquote>
<p>Une fois cela fait, le code suivant se connectera sans problème au serveur
wiremock ayant ce certificat auto-signé.</p>
<pre><code class="language-java">new OkHttpClient.Builder()
            .hostnameVerifier(allowAllHostNames())
            .build()
            .newCall(new Request.Builder().get()
                                          .url(&quot;https://localhost:8443&quot;)
                                          .build())
            .execute();
</code></pre>
<p>À noter que dans ce cas il y a toujours besoin d&rsquo;un <em>hostname verifier</em> car le
certificat de wiremock ne permet pas de valider que le hostname <em>localhost</em> ou
de ses IPs associées correspond à ce certificat (<a href="https://tools.ietf.org/html/rfc2818#section-3.1">RFC 2818</a>).</p>
<p>Quoiqu&rsquo;il en soit cette procédure demande une modification de la configuration de
l&rsquo;installation de JVM. C&rsquo;est pénible sur un poste de dévelopeur, c&rsquo;est pénible sur
le serveur de CI. Il y a moyen de mieux faire.</p>
<h4 id="en-utilisant-un-truststore-alternatif">En utilisant un truststore alternatif</h4>
<p>Avec cette approche un truststore alternatif est créé avec le même <code>keytool</code> :</p>
<p>À noter que le <strong>certificat</strong> au format <code>PEM</code> sera stockée dans un <strong>key</strong> store.
L&rsquo;extension <code>jks</code> vient du type de keystore, et correspond à Java Key Store.</p>
<pre><code class="language-sh">keytool -import \
        -alias wiremock \
        -file wiremock.pem \
        -keystore ./wiremock-truststore.jks
</code></pre>
<p>Le certificat est toujours au format PEM et sera stocké dans un fichier<br>
<code>wiremock-truststore.jks</code> de type <code>jks</code> (pour Java Key Store).</p>
<blockquote>
<p>Plutôt que de rentrer <em>interractivement</em> le mot de passe, en ajoutant
<code>-noprompt</code> et <code>-storepass &lt;password&gt;</code> on peut créer ce keystore sans
interaction.</p>
</blockquote>
<pre><code class="language-sh">keytool -import \
        -noprompt \
        -storepass changeit \
        -alias wiremock \
        -file wiremock.pem \
        -keystore ./wiremock-truststore.jks
</code></pre>
<p>Ensuite il faut lancer le programme java en passant les options</p>
<ul>
<li><code>-Djavax.net.ssl.trustStore=./wiremock-truststore.jks</code></li>
<li><code>-Djavax.net.ssl.trustStorePassword=changeit</code></li>
</ul>
<pre><code class="language-sh">java -Djavax.net.ssl.trustStore=./wiremock-truststore.jks \
     -Djavax.net.ssl.trustStorePassword=changeit \
     OkSSLConnect localhost 8443
</code></pre>
<p><code>OkSSLConnect</code> est le programme sensé établir la connexion au serveur wiremock,
c&rsquo;est le code OkHttp vu plus haut main dans un <code>main</code> qui prend en paramètre le
hostname et le port. S&rsquo;il n&rsquo;y a pas d&rsquo;erreur SSL, alors le truststore alternatif
contenant le certificat auto-signé a bien été utilisé.</p>
<p>En revanche si le programme doit se connecter sur un serveur ayant un certificat
auto-signé ou sur un autre serveur ayant lui une chaine de certificats signés
par des autorités reconnues, par exemple sur google.com, le programme lèvera
une <code>SSLHandshakeException</code>.</p>
<pre><code class="language-sh">java -Djavax.net.ssl.trustStore=./wiremock-truststore.jks \
     -Djavax.net.ssl.trustStorePassword=changeit \
     OkSSLConnect google.com 443
</code></pre>
<p>Sans le truststore <code>java OkSSLConnect google.com 443</code>, la connexion est établie
avec succès.</p>
<p>Cette approche n&rsquo;est donc pas non plus sans défaut, car les options de la JVM changent
le truststore global de cette instance de la JVM. Cette approche à les même défaut
que d&rsquo;importer un certificat, il faut configurer le démarrage de la JVM avec ces options
et en plus de ça activer cette propriété limite la connectivité à d&rsquo;autre serveur
(par exemple un plugin du système de build qui va se connecter sur l&rsquo;API de GitHub).
Cette approche n&rsquo;est probablement pas une solution acceptable.</p>
<h4 id="en-utilisant-programmatiquement-le-certificat-auto-signé">En utilisant programmatiquement le certificat auto-signé</h4>
<h5 id="à-partir-dun-truststore-jks">À partir d&rsquo;un truststore JKS</h5>
<p>Pour commencer on peut commencer par utiliser le truststore déjà créé par
<code>keytool</code>. Le code qui suit est séparé en plusieurs responsabilités :</p>
<ul>
<li>charger la factory de <code>TrustManager</code>, par défaut l&rsquo;algorithme choisi est
<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#TrustManagerFactory"><code>PKIX</code></a></li>
<li>charger le truststore, par défaut <code>KeyStore.getDefauktType()</code> retourne
<code>jks</code> <!-- raw HTML omitted --><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#KeyStore">[1]</a>
<a href="https://docs.oracle.com/javase/8/docs/api/java/security/KeyStore.html#getDefaultType--">[2]</a><!-- raw HTML omitted -->.</li>
<li>construire un nouveau trust manager à partir des données du truststore</li>
</ul>
<pre><code class="language-java">public static X509TrustManager trustManagerFor(KeyStore keyStore) {
    TrustManagerFactory tmf = trustManagerFactoryFor(keyStore);

    TrustManager[] trustManagers = tmf.getTrustManagers();
    if (trustManagers.length != 1) {
        throw new IllegalStateException(&quot;Unexpected number of trust managers:&quot;
                                                + Arrays.toString(trustManagers));
    }
    TrustManager trustManager = trustManagers[0];
    if (trustManager instanceof X509TrustManager) {
        return (X509TrustManager) trustManager;
    }
    throw new IllegalStateException(&quot;'&quot; + trustManager + &quot;' is not a X509TrustManager&quot;);
}


public static TrustManagerFactory trustManagerFactoryFor(KeyStore keyStore) {
    try {
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmf.init(keyStore);
        return tmf;
    } catch (KeyStoreException | NoSuchAlgorithmException e) {
        throw new IllegalStateException(&quot;Can't load trust manager for keystore : &quot; + keyStore, e);
    }
}


public static KeyStore readJavaKeyStore(Path javaKeyStorePath, String password) {
    try (InputStream inputStream = new BufferedInputStream(Files.newInputStream(javaKeyStorePath))) {
        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
        ks.load(inputStream, password.toCharArray());
        return ks;
    } catch (IOException e) {
        throw new UncheckedIOException(e);
    } catch (CertificateException | NoSuchAlgorithmException | KeyStoreException e) {
        throw new IllegalStateException(e);
    }
}
</code></pre>
<p>Enfin il faut initialiser le client OkHttp avec la socket factory</p>
<pre><code class="language-java">X509TrustManager trustManager = trustManagerFor(readJavaKeyStore(Paths.get(&quot;./wiremock-truststore.jks&quot;), &quot;changeit&quot;));
new OkHttpClient.Builder()
        .sslSocketFactory(sslContext(null, new TrustManager[]{trustManager}).getSocketFactory(),
                          trustManager)
        .hostnameVerifier(allowAllHostNames())
        .build()
        .newCall(new Request.Builder().get()
                                        .url(&quot;https://localhost:8443&quot;)
                                        .build())
        .execute();
</code></pre>
<p>Avec ce contexte on peut initialiser la majeure partie des clients HTTP.</p>
<h5 id="à-partir-du-certificat-au-format-pem">À partir du certificat au format <code>PEM</code></h5>
<p>Le code suivant va créer un keystore en mémoire qui va accueillir le certificat
X.509 (c&rsquo;est à dire le certificat extrait depuis la commande <code>openssl x509 -outform pem</code>).</p>
<pre><code class="language-java">public static KeyStore makeJavaKeyStore(Path certificatePath) {
    try (BufferedInputStream bis = new BufferedInputStream(Files.newInputStream(certificatePath))) {
        CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);

        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
        ks.load(null, null);
        int certificate_counter = 0;
        for (X509Certificate certificate : (Collection&lt;X509Certificate&gt;) cf.generateCertificates(bis)) {
            ks.setCertificateEntry(&quot;cert_&quot; + certificate_counter++, certificate);
        }

        return ks;
    } catch (IOException e) {
        throw new UncheckedIOException(e);
    } catch (CertificateException e) {
        throw new IllegalStateException(&quot;Can't load certificate : &quot; + certificatePath, e);
    } catch (KeyStoreException | NoSuchAlgorithmException e) {
        throw new IllegalStateException(&quot;Can't create the internal keystore for certificate : &quot; + certificatePath, e);
    }
}
</code></pre>
<p>Ce bout de code lit un fichier de certificat X509 et importe le ou les certificats
dans le <code>KeyStore</code> créé en mémoire.</p>
<hr>
<p><strong>Pour rappel :</strong></p>
<p>La javadoc de la méthode <a href="https://docs.oracle.com/javase/8/docs/api/java/security/cert/CertificateFactory.html#generateCertificate-java.io.InputStream-"><code>CertificateFactory.generateCertificate(InputStream)</code></a>
indique précisément que le format supporté doit être <strong>X.509</strong></p>
<ul>
<li>au format <code>PEM</code>, c&rsquo;est à dire le fichier contiens les balises
<code>-----BEGIN CERTIFICATE-----</code> et <code>-----END CERTIFICATE-----</code> avec une payload
ASCII encodée en <em>base 64</em></li>
<li>au format <code>DER</code> qui en est la représentation binaire (qu&rsquo;on peut obtenir avec
<code>openssl x509 -in wiremock.pem -outform der &gt; wiremock.der</code>).</li>
</ul>
<blockquote>
<p>In the case of a certificate factory for X.509 certificates, the certificate
provided in inStream must be DER-encoded and may be supplied in binary or
printable (Base64) encoding. If the certificate is provided in Base64 encoding,
it must be bounded at the beginning by <code>-----BEGIN CERTIFICATE-----</code>, and must be
bounded at the end by <code>-----END CERTIFICATE-----</code>.</p>
</blockquote>
<p>Ensuite il suffira de créer un trust manager avec le <code>KeyStore</code> créé par cette méthode :</p>
<pre><code class="language-java">X509TrustManager trustManager = trustManagerFor(makeJavaKeyStore(Paths.get(&quot;./wiremock.pem&quot;)));
new OkHttpClient.Builder()
        .sslSocketFactory(sslContext(null, new TrustManager[]{trustManager}).getSocketFactory(),
                          trustManager)
        .hostnameVerifier(allowAllHostNames())
        .build()
        .newCall(new Request.Builder().get()
                                        .url(&quot;https://localhost:8443&quot;)
                                        .build())
        .execute();
</code></pre>
<hr>
<h3 id="en-utilisant-à-la-fois-la-chaine-de-confiance-existante-et-le-certificat-auto-signé">En utilisant à la fois la chaine de confiance existante et le certificat auto-signé</h3>
<p>Si le client HTTPS doit se connecter à la fois à des tiers ayant une chaine de
confiance remontant à une autorité connue et à un ou des tiers ayant un certificat
auto-signé.</p>
<p>L&rsquo;idée est simple, on peut fabriquer un trust manager composite qui va déléguer
la validation aux trust managers configurés.</p>
<pre><code class="language-java">public class CompositeX509TrustManager implements X509TrustManager {
    private final List&lt;X509TrustManager&gt; trustManagers;

    public CompositeX509TrustManager(X509TrustManager... trustManagers) {
        this.trustManagers = Arrays.asList(trustManagers);
    }

    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        new MultiException&lt;&gt;(new CertificateException(&quot;This certification chain couldn't be trusted&quot;))
                .collectFrom(trustManagers.stream(),
                             trustManager -&gt; trustManager.checkClientTrusted(chain, authType))
                .scream(UNLESS_ANY_SUCCESS);
    }

    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        new MultiException&lt;&gt;(new CertificateException(&quot;This certification chain couldn't be trusted&quot;))
                .collectFrom(trustManagers.stream(),
                             trustManager -&gt; trustManager.checkServerTrusted(chain, authType))
                .scream(UNLESS_ANY_SUCCESS);
    }

    @Override
    public X509Certificate[] getAcceptedIssuers() {
        return trustManagers.stream()
                            .map(X509TrustManager::getAcceptedIssuers)
                            .flatMap(Arrays::stream)
                            .toArray(X509Certificate[]::new);
    }
}
</code></pre>
<p><code>MultiException</code> est un petit utilitaire qui me permet de collecter plusieurs
exceptions remontées par une variété d&rsquo;appels, et de ne lever qu&rsquo;une seule
exception (parente), ce mécanisme utilise <code>Throwable.addSuppressed</code> ajouté
en Java 1.7 pour supporter les blocs <em>try-with-resources</em>.</p>
<pre><code class="language-java">public class MultiException&lt;E extends Exception&gt; {
    private final E parent;
    private boolean successMarker = false;

    public MultiException(E parent, Exception... exceptions) {
        this.parent = parent;
        Arrays.stream(exceptions).forEach(parent::addSuppressed);
    }

    public &lt;T&gt; MultiException&lt;E&gt; collectFrom(Stream&lt;T&gt; stream, ThrowingConsumer&lt;T&gt; invocation) {
        stream.forEach(t -&gt; collect(t, invocation).ifPresent(parent::addSuppressed));
        return this;
    }

    private &lt;T&gt; Optional&lt;Exception&gt; collect(T type, ThrowingConsumer&lt;T&gt; throwing) {
        try {
            throwing.accept(type);

            successMarker = true;
            return Optional.empty();
        } catch (Exception e) {
            return Optional.of(e);
        }
    }

    public void scream(Mode mode) throws E {
        if (Mode.UNLESS_ANY_SUCCESS == mode &amp;&amp; successMarker) {
            return;
        }
        if (parent.getSuppressed().length &gt; 0) {
            throw parent;
        }
    }

    @FunctionalInterface
    public interface ThrowingConsumer&lt;T&gt; {
        void accept(T type) throws Exception;
    }

    public enum Mode {
        UNLESS_ANY_SUCCESS,
        ANY_FAILURE
    }
}
</code></pre>
<p>Ce gestionnaire composite s&rsquo;utilisera de cette façon :</p>
<pre><code class="language-java">X509TrustManager compositeTrustManager = new CompositeX509TrustManager(
        trustManagerFor(makeJavaKeyStore(Paths.get(&quot;./wiremock.pem&quot;))),
        systemTrustManager());
OkHttpClient okHttpClient = httpClient(sslContext(null,
                                                  new TrustManager[]{compositeTrustManager}),
                                        compositeTrustManager)
        .newBuilder()
        .hostnameVerifier(allowAllHostname())
        .build();
</code></pre>
<p>Ce client pourra exécuter sans problèmes des requêtes sur des serveurs dont les autorités
de certifications sont connus et sur des serveurs ayant une chaine de certification
plus obscure.</p>
<h2 id="coté-serveur">Coté serveur</h2>
<p>On a vu le coté client, mais se baser sur le certificat de wiremock, n&rsquo;est
peut-être pas le plus correct d&rsquo;un point de vue test.</p>
<h3 id="génération-du-certificat-auto-signé-avec-keytool">Génération du certificat auto-signé avec <code>keytool</code></h3>
<p>Créons notre propre certificat auto-signé :</p>
<pre><code class="language-sh">keytool -genkey \
        -keyalg RSA \
        -alias bric3 \
        -keystore bric3.jks \
        -storepass the_password \
        -validity 360 \
        -keysize 2048
</code></pre>
<p><code>keytool</code> va nous poser des questions pour remplir successivement ces différents
attributs :</p>
<ul>
<li><code>CN</code> (<strong>C</strong>ommon <strong>N</strong>ame)</li>
<li><code>OU</code> (<strong>O</strong>rganizational <strong>U</strong>nit)</li>
<li><code>O</code> (<strong>O</strong>rganization)</li>
<li><code>L</code> (<strong>L</strong>ocality)</li>
<li><code>ST</code> (<strong>ST</strong>ate)</li>
<li><code>C</code> (<strong>C</strong>ountry)</li>
</ul>
<p>et enfin <code>keytool</code> finira par le password du certificat, à ne pas confondre
avec le password du keystore. On peut rendre la génération non interactive en
donnant les options :</p>
<ul>
<li><code>-keypass password</code></li>
<li><code>-dname 'CN=Brice Duhteil, OU=Arkey, O=Arkey, L=Paris, ST=France, C=FR'</code></li>
</ul>
<blockquote>
<p><code>dname</code> correspond à <strong>D</strong>istinguished <strong>N</strong>ames</p>
</blockquote>
<p>Enfin ce certificat a le même problème que celui qui vient avec wiremock,
car il demande de modifier le hostname verifier (<a href="https://tools.ietf.org/html/rfc2818#section-3.1">RFC 2818</a>).
Ce problème peut être corrigé en ajoutant une section <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.6"><code>SAN</code> (<strong>S</strong>ubject
<strong>A</strong>lternative <strong>N</strong>ames)</a>
qui peut notamment contenir des noms DNS et des adresses IP. Avec
<code>keytool</code> il faut passer l&rsquo;option <code>-ext</code> et passer les options <code>dns</code> ou <code>ip</code> :</p>
<pre><code>-ext SAN=dns:domain.com,dns:localhost,ip:127.0.0.1
</code></pre>
<p>Par exemple si je veux indiquer que ce certificat est valide pour les serveurs</p>
<ul>
<li><code>blog.arkey.pro</code></li>
<li><code>blog</code></li>
<li><code>127.0.0.1</code></li>
<li><code>::1</code></li>
</ul>
<pre><code class="language-sh">keytool -genkey \
        -keyalg RSA \
        -alias bric3 \
        -keystore bric3.jks \
        -storepass the_password \
        -validity 360 \
        -keysize 2048 \
        -keypass the_password \
        -dname 'CN=Brice Duhteil, OU=Arkey, O=Arkey, L=Paris, ST=France, C=FR' \
        -ext 'SAN=dns:blog.arkey.fr,dns:blog,dns:localhost,ip:127.0.0.1,ip:::1'
</code></pre>
<hr>
<p><strong>À noter #1:</strong></p>
<ol>
<li><code>keytool</code> génère le certificat et le stocke directement dans le <strong>J</strong>ava
<strong>K</strong>ey <strong>S</strong>tore</li>
<li>wiremock ne permet de configurer qu&rsquo;un seul mot de passe du certificat, à la
fois pour la clé du certificat et pour le <strong>J</strong>ava <strong>K</strong>ey <strong>S</strong>tore ; à la
création il faut donc absolument utiliser même mot de passe pour le JKS et
le certificat e.g. : <code>-storepass the_password</code> et <code>-keypass the_password</code>.</li>
</ol>
<p><strong>À noter #2:</strong></p>
<p><code>keytool</code> valide l&rsquo;entrée DNS, mais ne gère pas tous les caractères possibles
d&rsquo;un domaine, pour cette raison il est préférable d&rsquo;utiliser <code>openssl</code> ou équivalent
pour générer ces certificats. Une partie intéressante de la spécification PKIX /
X509 est l&rsquo;extension <em>Subject Alt Names</em> du format X509 version 3;
elle permet de donner d&rsquo;indiquer les <em>noms</em> de serveurs pour les quels ce certificat
a été émis (plutôt que le nom renseigné dans l&rsquo;attribut <em>Common Name</em>).
Un intérêt de cet attribut est qu&rsquo;il est également possible de donner des noms ayant un
<a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.6">wildcards</a>, ceci dit la logique du client
n&rsquo;est pas couverte dans cette RFC.</p>
<blockquote>
<p>Finally, the semantics of subject alternative names that include
wildcard characters (e.g., as a placeholder for a set of names) are
not addressed by this specification.  Applications with specific
requirements MAY use such names, but they must define the semantics.</p>
</blockquote>
<p>Par exemple le certificat de <strong>google.com</strong> est configuré avec des domaines étant
préfixés par un wildcard:</p>
<pre><code class="language-sh">echo -n | openssl s_client -showcerts -connect google.com:443 2&gt;&amp;1 | openssl x509 -text
</code></pre>
<pre><code>X509v3 Subject Alternative Name: 
    DNS:*.google.com, DNS:*.android.com, DNS:*.appengine.google.com, DNS:*.cloud.google.com, DNS:*.db833953.google.cn, DNS:*.g.co, DNS:*.gcp.gvt2.com, DNS:*.google-analytics.com, DNS:*.google.ca, DNS:*.google.cl, DNS:*.google.co.in, DNS:*.google.co.jp, DNS:*.google.co.uk, DNS:*.google.com.ar, DNS:*.google.com.au, DNS:*.google.com.br, DNS:*.google.com.co, DNS:*.google.com.mx, DNS:*.google.com.tr, DNS:*.google.com.vn, DNS:*.google.de, DNS:*.google.es, DNS:*.google.fr, DNS:*.google.hu, DNS:*.google.it, DNS:*.google.nl, DNS:*.google.pl, DNS:*.google.pt, DNS:*.googleadapis.com, DNS:*.googleapis.cn, DNS:*.googlecommerce.com, DNS:*.googlevideo.com, DNS:*.gstatic.cn, DNS:*.gstatic.com, DNS:*.gvt1.com, DNS:*.gvt2.com, DNS:*.metric.gstatic.com, DNS:*.urchin.com, DNS:*.url.google.com, DNS:*.youtube-nocookie.com, DNS:*.youtube.com, DNS:*.youtubeeducation.com, DNS:*.yt.be, DNS:*.ytimg.com, DNS:android.clients.google.com, DNS:android.com, DNS:developer.android.google.cn, DNS:developers.android.google.cn, DNS:g.co, DNS:goo.gl, DNS:google-analytics.com, DNS:google.com, DNS:googlecommerce.com, DNS:source.android.google.cn, DNS:urchin.com, DNS:www.goo.gl, DNS:youtu.be, DNS:youtube.com, DNS:youtubeeducation.com, DNS:yt.be
</code></pre>
<hr>
<h3 id="génération-du-certificat-auto-signé-avec-openssl">Génération du certificat auto-signé avec <code>openssl</code></h3>
<p><code>keytool</code> c&rsquo;est bien, mais l&rsquo;outillage de référence est quand même le couteau
suisse openssl.</p>
<h4 id="sous-section-uniquement-pour-openssl">Sous-section uniquement pour <code>openssl</code></h4>
<p>Pour générer un certificat auto-signé il faut en réalité plusieurs étapes</p>
<ol>
<li>
<p>Générer une clé privée pour le domaine</p>
<pre><code class="language-sh">openssl genrsa \
    -out bric3-private.key \
    2048
</code></pre>
<p>Cette commande créé un clé privée de 2048 bit en utilisant l&rsquo;algorithme RSA.
Cette clé n&rsquo;est pas protégé par mot de passe (option <code>-des3</code>).</p>
</li>
<li>
<p>Faire la demande d&rsquo;un certificat (façon non-interactive)</p>
<pre><code class="language-sh">openssl req \
    -new \
    -outform pem \
    -out bric3-self.csr \
    -keyform pem \
    -key bric3-private.key \
    -sha256 \
    -config &lt;(cat &lt;&lt;-EOF

[req]
prompt = no
req_extensions = bric3_req_ext
distinguished_name = dn
   
[dn]
CN=Brice Dutheil
O=Arkey
OU=Arkey
L=Paris
ST=France
C=FR

[bric3_req_ext]
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
DNS.2 = arkey.fr
DNS.3 = *.arkey.fr
DNS.4 = arkey.pro
DNS.5 = *.arkey.pro
DNS.6 = blog
IP.1 = 127.0.0.1
IP.2 = ::1

EOF
)
</code></pre>
<p>Ce demande génère un fichier CSR (<strong>C</strong>ertificate <strong>S</strong>ign <strong>R</strong>equest) au format PEM.
Il prend la clé privé du propriétaire des serveurs au format PEM. Les informations qui
concernent la configuration de l&rsquo;émission du CSR sont indiquées dans un fichier de config
(dans cette commande passée via un stream <code>&lt;(cat &lt;&lt;-MARKER ... MARKER)</code>).</p>
<p>On y retrouve une section <code>[req]</code>, indiquant le mode non interactif <code>prompt = no</code>,
le lien vers la section du <strong>D</strong>istinguished <strong>N</strong>ame <code>distinguished_name = dn</code>,
l&rsquo;emplacement de l&rsquo;extension portant sur les le <strong>S</strong>ubject <strong>A</strong>lt <strong>N</strong>ame
<code>req_extensions = bric3_req_ext</code>.</p>
<p>La section<code>[dn]</code> contiens ce qui compose le DN, le <strong>C</strong>ommon <strong>N</strong>ame, etc.</p>
<p>La section des noms alternatifs aura les différentes entrées possibles, de type <code>DNS</code>,
de type <code>IP</code>, etc.</p>
<p>Enfin à noter que sans le paramètre <code>req_extensions = bric3_req_ext</code>, il aurait
fallu passer l&rsquo;option en ligne de commande <code>-requexts bric3_req_ext</code>).</p>
<p>Pour plus d&rsquo;info sur la commande <code>req</code> et sa configuration, il faut parcourir la page
<a href="https://www.openssl.org/docs/manmaster/man1/req.html">man (branche master)</a>.</p>
</li>
<li>
<p>Signer la requête pour générer le certificat</p>
<pre><code class="language-sh">openssl x509 \
    -req \
    -days 3650 \
    -inform pem \
    -in bric3-self.csr \
    -signkey bric3-private.key \
    -outform pem \
    -out bric3-self.pem \
    -extensions bric3_ext \
    -extfile &lt;(cat &lt;&lt;-EOF
[bric3_ext]
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
DNS.2 = arkey.fr
DNS.3 = *.arkey.fr
DNS.4 = arkey.pro
DNS.5 = *.arkey.pro
DNS.6 = blog
IP.1 = 127.0.0.1
IP.2 = ::1
EOF
)
</code></pre>
<p>Cette commande <code>x509</code> génère donc un certificat X509 depuis la requête de
signature (<code>-req</code>). En entrée il y a donc la requête <code>-in bric3-self.csr</code> et
comme il s&rsquo;agit d&rsquo;un certificat auto-signé il faut donner sa propre clé
privée <code>-signkey bric3-private.key</code>, (autrement il s&rsquo;agirait de la clé
privée de l&rsquo;autorité de certification). Le certificat émis sera valide pour
10 ans (<code>-days 3650</code>).</p>
<p>Cette commande ne récupère pas les extensions depuis la requête de signature
de certificat, par conséquent il faut lui donner l&rsquo;info dans un fichier de
configuration ou par un stream <code>-extfile &lt;(cat &lt;&lt;-EOF ... EOF)</code>, il faut
également passer le nom de la section, ici <code>-extensions bric3_ext</code>.</p>
<p>Si tout est bon un certificat <code>bric3-self.pem</code> est généré.</p>
<p>Pour plus d&rsquo;info sur la commande <code>x509</code> et sa configuration, il faut parcourir
la page <a href="https://www.openssl.org/docs/manmaster/man1/x509.html">man (branche master)</a>.</p>
</li>
</ol>
<p>La configuration est bien entendu plus compliqué lorsqu&rsquo;il faut faire les étapes
complètes avec une <em>autorité de certification</em> et une chaine de certificats plus
élaborée.</p>
<p>Ces trois étapes peuvent être réduite en une seule pour les certificats auto-signés.</p>
<pre><code class="language-sh">openssl req \
    -new \
    -nodes \
    -sha256 \
    -newkey rsa:2048 \
    -keyform pem \
    -keyout bric3-openssl.key \
    -x509 \
    -days 3650 \
    -outform pem \
    -out bric3-openssl.crt \
    -config &lt;(cat &lt;&lt;-EOF
[req]
prompt = no
distinguished_name = dn
x509_extensions = bric3_ext

[dn]
CN=Brice Dutheil
O=Arkey
OU=Arkey
L=Paris
ST=France
C=FR

[bric3_ext]
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
DNS.2 = arkey.fr
DNS.3 = *.arkey.fr
DNS.4 = arkey.pro
DNS.5 = *.arkey.pro
DNS.6 = blog
IP.1 = 127.0.0.1
IP.2 = ::1
EOF
)
</code></pre>
<p>La commande est <code>req</code></p>
<ul>
<li>avec l&rsquo;option <code>-newkey rsa:2048</code> qui permet de générer une clé RSA de longueur 2048.
Cette clé sera enregistré dans le fichier <code>bric3-openssl.key</code> au format PEM.</li>
<li>avec l&rsquo;option <code>-x509</code> qui indique que le résultat de sortie ne sera pas
une requête de signature mais le certificat signé (au format X509).
Celui-ci aura une validité de 10 ans <code>-days 3650</code> et sera enregistré dans le fichier
<code>bric3-openssl.crt</code> au format PEM. Comme l&rsquo;option <code>-x509</code> est activée, il faut utiliser
dans notre configuration le paramètre <code>x509_extensions = bric3_ext</code> pour indiquer
la section correspondante (au lieu de <code>req_extensions</code>).</li>
</ul>
<hr>
<p>À noter que <code>subjectAltName = @alt_names</code> permet de lister <em>verticalement</em> une liste de
valeurs dans la section <code>alt_names</code>, e.g.</p>
<pre><code>[bric3_ext]
subjectAltName = DNS.1 : localhost, DNS.3 : arkey.fr, DNS.3 : *.arkey.fr, DNS.4 : arkey.pro, DNS.5 : *.arkey.pro, DNS.6 : blog, IP.1 : 127.0.0.1, IP.2 : ::1
</code></pre>
<p>est équivalent à</p>
<pre><code>[bric3_ext]
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
DNS.2 = arkey.fr
DNS.3 = *.arkey.fr
DNS.4 = arkey.pro
DNS.5 = *.arkey.pro
DNS.6 = blog
IP.1 = 127.0.0.1
IP.2 = ::1
</code></pre>
<p>Il y a quelques différences de syntaxe</p>
<ul>
<li>utilisation de deux points <code>:</code> avec d&rsquo;un coté le type de nom alternatif
(<code>IP</code>, <code>DNS</code>, etc.)  pour la liste.</li>
<li>utilisation d&rsquo;une notation <em>indexée</em> post-fixée au type du nom alternatif
pour la liste dans une section (<code>DNS.1</code>, <code>DNS.2</code>, etc.).</li>
</ul>
<hr>
<p>Enfin pour utiliser sur la JVM ce certificat et cette clé il faut les packager
ensemble. Les librairies standards de la JVM peuvent charger un <strong>J</strong>ava <strong>K</strong>ey
<strong>S</strong>tore ou un fichier P12 (<strong>PKCS12</strong>).</p>
<pre><code class="language-sh">openssl pkcs12 \
    -export \
    -in bric3-openssl.crt \
    -inkey bric3-openssl.key \
    -passout pass:cadeau \
    -out bric3.p12
</code></pre>
<p>Pour créer un java keystore depuis ce fichier PKCS12 :</p>
<pre><code class="language-sh">keytool -importkeystore \
        -srckeystore bric3.p12 \
        -srcstoretype PKCS12 \
        -srcstorepass cadeau \
        -deststorepass the_password \
        -destkeypass the_password \
        -destkeystore bric3-openssl.jks
</code></pre>
<h3 id="chargement-du-certificat-dans-la-jvm">Chargement du certificat dans la JVM</h3>
<p>Pour utiliser ce certificat il faut le charger dans wiremock et dans le client :</p>
<pre><code class="language-java">@Rule
public WireMockRule wireMockRule = new WireMockRule(wireMockConfig().dynamicPort()
                                                                    .keystorePath(&quot;./bric3.jks&quot;)
                                                                    .keystorePassword(&quot;the_password&quot;)
                                                                    .dynamicHttpsPort());

@Test
public void my_precious_self_signed_certificate() throws IOException {
    X509TrustManager compositeTrustManager = new CompositeX509TrustManager(
            trustManagerFor(readJavaKeyStore(Paths.get(&quot;./bric3.jks&quot;), &quot;the_password&quot;)),
            systemTrustManager());
    OkHttpClient okHttpClient = httpClient(sslContext(null,
                                                        new TrustManager[]{compositeTrustManager}),
                                            compositeTrustManager)
            .newBuilder()
            .build();
    try (Response response = okHttpClient.newCall(new Request.Builder().get()
                                                                       .url(format(&quot;https://%s:%d&quot;,
                                                                                   &quot;localhost&quot;,
                                                                                   wireMockRule.httpsPort()))
                                                                       .build())
                                         .execute()) {
        // successfully established connection
    }
}
</code></pre>
<p>Wiremock utilise Jetty sous le capot et qui ne permet pas d&rsquo;utiliser un fichier p12.
Bien que toutes les <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#impl">implémentations de la JVM</a>
sont tenues d&rsquo;implémenter le chargement de keystore au format PKCS12, Jetty ne
<a href="https://wiki.eclipse.org/Jetty/Howto/Configure_SSL#Loading_Keys_and_Certificates_via_PKCS12">supporte pas directement les fichiers p12</a>,
il faut donc convertir le fichier p12 en <strong>J</strong>ava <strong>K</strong>ey <strong>S</strong>tore.</p>
<h2 id="pour-conclure">Pour conclure</h2>
<p>Dans cet article on a pu découvrir comment gérer un certificat auto-signé en java,
et comment créer nos propres certificats auto-signés à l&rsquo;aide d&rsquo;outils quasi
standard. À travers les exemples on a pu découvrir quelques classes qui composent
les fonctionnalités de sécurité de la JVM.</p>
<p>Il y a plus de choses à approfondir avec TLS, par exemple construire sa propre
autorité de certification et gérer la vérification de cette chaine de certificat,
ou encore l&rsquo;authentification mutuelle (le client authentifie le serveur et le
serveur authentifie le client). Ou encore comment la librairie
<a href="https://www.bouncycastle.org/java.html">BouncyCastle</a> s&rsquo;intègre dans ce mécanisme.</p>
<h3 id="versions">Versions</h3>
<p>Cet article a été élaboré avec les versions suivantes</p>
<ul>
<li>Java 1.8.0u144</li>
<li>okhttp 3.9.0</li>
<li>wiremock 2.8.0</li>
<li>High Sierra / OSX 10.13 / Darwin 17.0.0 / 17A405</li>
<li>openssl =&gt; LibreSSL 2.2.7 (High Sierra vient avec LibreSSL)</li>
</ul>
<h3 id="quelques-références">Quelques références</h3>
<ul>
<li><a href="https://www.openssl.org">https://www.openssl.org</a></li>
<li><a href="https://www.libressl.org">https://www.libressl.org</a></li>
<li><a href="http://wiki.cacert.org/FAQ/subjectAltName">http://wiki.cacert.org/FAQ/subjectAltName</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-ssl-certificate-on-apache-for-ubuntu-14-04">https://www.digitalocean.com/community/tutorials/how-to-create-a-ssl-certificate-on-apache-for-ubuntu-14-04</a></li>
<li><a href="https://tools.ietf.org/html/rfc5280">https://tools.ietf.org/html/rfc5280</a></li>
<li><a href="https://tools.ietf.org/html/rfc2818">https://tools.ietf.org/html/rfc2818</a></li>
<li><a href="https://tools.ietf.org/html/rfc5246">https://tools.ietf.org/html/rfc5246</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html">https://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html</a></li>
</ul>




  </div>
  

<div class="navigation navigation-single">
    
    <a href="/2017/10/19/self-signed-certificates-in-java.en/" class="navigation-prev">
      <i aria-hidden="true" class="fa fa-chevron-left"></i>
      <span class="navigation-tittle">HTTPS in Java with a self-signed certificate</span>
    </a>
    
    
    <a href="/2018/06/18/minikube-with-hyperkit/" class="navigation-next">
      <span class="navigation-tittle">Minikube with hyperkit</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  

  <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
        
        
        
        this.page.identifier = 'https://blog.arkey.fr/2017/10/19/self-signed-certificates-in-java/';
        this.page.title = 'HTTPS en Java avec un certificat auto-signé';
        this.page.url = 'https://blog.arkey.fr/2017/10/19/self-signed-certificates-in-java/';
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "thecoffeeworkshop" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</article>


            
    
<footer>

 
 
 <div class="github-edit">
     <a href="https://github.com/bric3/bric3.github.io/edit/hugo-sources/content/posts/2017-10-19-self-signed-certificates-in-java.md">
     <i class="fab fa-github fa-lg" aria-hidden="true"></i> Edit this page
     </a>
 </div>
 














<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/highlight.min.js" integrity="sha512-DrpaExP2d7RJqNhXB41Q/zzzQrtb6J0zfnXD5XeVEWE8d9Hj54irCLj6dRS3eNepPja7DvKcV+9PnHC7A/g83A==" crossorigin="anonymous"></script>
    <script type="text/javascript">
        
        hljs.initHighlightingOnLoad();
    </script>
    

<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js" integrity="sha256-vrn14y7WH7zgEElyQqm2uCGSQrX/xjYDjniRUQx3NyU=" crossorigin="anonymous"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

function globalSwitch() {
	$('.switch--item').each(function() {
		var blockId = blockIdForSwitchItem($(this));
		$(this).off('click');
		$(this).on('click', function() {
			selectedText = $(this).text()
			window.localStorage.setItem(blockId, selectedText);
			$(".switch--item").filter(function() {
				return blockIdForSwitchItem($(this)) === blockId;
			}).filter(function() {
				return $(this).text() === selectedText;
			}).each(function() {
				select($(this))
			});
		});
		if ($(this).text() === window.localStorage.getItem(blockId)) {
			select($(this))
		}
	});
}

function blockIdForSwitchItem(item) {
	idComponents = []
	idComponents.push(item.text().toLowerCase());
	item.siblings(".switch--item").each(function(index, sibling) {
		idComponents.push($(sibling).text().toLowerCase());
	});
	return idComponents.sort().join("-")
}

function select(selected) {
	selected.addClass('selected');
	selected.siblings().removeClass('selected');
	selectedContent = selected.parent().siblings(".content").eq(selected.index())
	selectedContent.removeClass('hidden');
	selectedContent.siblings().addClass('hidden');
}

$(addBlockSwitches);
$(globalSwitch);
</script>



</footer>

    



        </div>
    </body>
</html>

