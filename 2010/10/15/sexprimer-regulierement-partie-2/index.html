<!DOCTYPE html>
<html lang="en">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.69.0" />

    
    
    

<title>Expressions régulières (Partie 2) • The Coffee Workshop</title>













    
<meta property="og:locale" content="en">
<meta property="og:site_name" content="The Coffee Workshop">
<meta property="og:title" content="Expressions régulières (Partie 2)">
<meta property="og:type" content="website">
<meta property="og:url" content="https://blog.arkey.fr/2010/10/15/sexprimer-regulierement-partie-2/" />
<meta property="og:description" content="Java mostly, and general tech">
<meta property="og:image" content="https://blog.arkey.fr/social-sharing.png">
<meta property="og:image:type" content="image/png">
    
    
    
<meta property="og:image:width" content="192">
<meta property="og:image:height" content="192">
    

<meta property="og:updated_time" content="2010-10-15T14:40:15Z">



<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@BriceDutheil">
<meta name="twitter:title" content="Expressions régulières (Partie 2)">

<meta name="twitter:image" content="https://blog.arkey.fr/social-sharing.png">

<meta name="twitter:description" content="Java mostly, and general tech">
<meta name="twitter:creator" content="@BriceDutheil">
    
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/gruvbox-dark.min.css" media="(prefers-color-scheme: dark)">




<link rel="stylesheet" href="/scss/hyde-hyde.01bbc8b24ee2a8e7fce257f4a49e727f6b1cf3632729d5d17cc0529a5c26ffbd.css" integrity="sha256-AbvIsk7iqOf84lf0pJ5yf2sc82MnKdXRfMBSmlwm/70=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    
    <link rel="shortcut icon" sizes="192x192" href="/android-192-favicon.png">

    
    <link rel="shortcut icon" href="/android-192-favicon.png">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" integrity="sha256-h20CPZ0QyXlBuAw7A+KluUYx/3pK+c7lYEpqLTlxjYQ=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/v4-shims.min.css" integrity="sha256-wN7QJaqAwQ03kgUhyN4EU2phRdDkLrQYbFe0EvpQ60U=" crossorigin="anonymous" />

    
    


    
</head>


    <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://blog.arkey.fr">The Coffee Workshop</a>
      </span>
      
      
        <div class="author-image">
          <img src="https://www.gravatar.com/avatar/f31c7fbcbb0766d0632d96fd7e74b649?s=240&d=mp" class="img--circle img--headshot element--center" alt="gravatar">
        </div>
      
      <p class="site__description">
         Java mostly, and general tech 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">The Coffee Workshop</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/"><span class='fa-icon'><i class='fas fa-home'></i></span><code>cd <em>~</em></code>
						<span></span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/posts/"><span class='fa-icon'><i class='fas fa-stream'></i></span><code>ls <em>posts/*</em></code>
						<span></span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/series/"><span class='fa-icon'><i class='fas fa-list-alt'></i></span><code>grep -o <em>series</em> posts/* | sort -u</code>
						<span></span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/tags/"><span class='fa-icon'><i class='fas fa-tags'></i></span><code>grep -o <em>tags</em> posts/* | sort -u</code>
						<span></span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/cool-stuff/"><span class='fa-icon'><i class='fas fa-thumbtack'></i></span><code>cd <em>cool-stuff</em></code>
						<span></span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/whoami/"><span class='fa-icon'><i class='fas fa-id-card'></i></span><code>whoami</code>
						<span></span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	<a href="https://twitter.com/@BriceDutheil" rel="me"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="bird" class="svg-inline--fa fa-bird fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a>
	
	
	
	<a href="https://github.com/bric3" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	<a href="https://speakerdeck.com/bric3" rel="me"><i class="fab fa-speaker-deck" aria-hidden="true"></i></i></a>
	
	
	
	
	
	
	
	<a href="https://linkedin.com/in/dutheilbrice" rel="me"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="pro-network" class="svg-inline--fa fa-pro-network fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a>
	
	
	<a href="https://stackoverflow.com/users/48136/brice" rel="me"><i class="fab fa-stack-overflow fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
</section>

      </div>
    </div>
    
<div class="copyright">
  &copy; 2010 - 2020 Brice Dutheil
  
    <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
  
</div>



  </div>
</div>

        <div class="content container">
            
    
<article>
  <header>
    <h1>Expressions régulières (Partie 2)</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> 2010-10-15
    
    
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/code">code</a>
           
      
          <a class="badge badge-tag" href="/tags/expression-reguliere">expression régulière</a>
           
      
          <a class="badge badge-tag" href="/tags/pattern">pattern</a>
           
      
          <a class="badge badge-tag" href="/tags/regex">regex</a>
           
      
          <a class="badge badge-tag" href="/tags/regexp">regexp</a>
           
      
          <a class="badge badge-tag" href="/tags/regular-expression">regular expression</a>
           
      
          <a class="badge badge-tag" href="/tags/backreference">backreference</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 33 min read

    
    <div class="page-series">
        <div class="title">In the same series :</div>
        <ul>
            
                
                <li hugo-nav="/2010/11/04/sexprimer-regulierement-partie-3/"><a href="https://blog.arkey.fr/2010/11/04/sexprimer-regulierement-partie-3/"> Expressions régulières (Partie 3) </a> </li>
                
                <li hugo-nav="/2010/10/15/sexprimer-regulierement-partie-2/"><a href="https://blog.arkey.fr/2010/10/15/sexprimer-regulierement-partie-2/"> Expressions régulières (Partie 2) </a> </li>
                
                <li hugo-nav="/2010/09/27/sexprimer-regulierement-partie-1/"><a href="https://blog.arkey.fr/2010/09/27/sexprimer-regulierement-partie-1/"> Expressions régulières (Partie 1) </a> </li>
                
            
        </ul>
    </div>

</div>


  </header>
  
  
  <div class="post">
    <p>La première partie de cette mini-série s&rsquo;est focalisée sur une petite intro, je n&rsquo;ai pas vraiment insisté sur
les bases des expressions régulières, j&rsquo;ai juste abordé les ancres et les options, et j&rsquo;ai parlé de certaines astuces
à connaître. La suite de cette série continue comme prévu sur les constructions suivantes :</p>
<ul>
<li>Les groupes qui ne capturent pas (<em>non-capturing group</em>)</li>
<li>Les backreferences</li>
<li>Les autres quantificateurs
<ul>
<li>Les quantificateurs gourmands (dits <em>greedy quantifiers</em>)</li>
<li>Les quantificateurs paresseux (dits <em>lazy quantifiers</em> ou comme le dit la javadoc de <code>Pattern</code> <em>reluctant quantifiers</em>)</li>
<li>Les quantificateurs possessifs (dits <em>possessive quantifiers</em>)</li>
</ul>
</li>
</ul>
<h1 id="le-backtracking">Le backtracking</h1>
<p>Certaines des constructions présentées ici démontrent que le moteur de regex de java fait partie des toutes
dernières générations. Afin de mieux expliquer la manière de fonctionner des quantificateurs, je vais faire un tour
sur la technique de backtracking du moteur de regex, feature essentiel pour faire fonctionner ces constructions.</p>
<p>Et aussi pourquoi certaines expressions régulières sont risquées en ce qui concerne les performances.</p>
<p>Mais d&rsquo;abord concentration sur les groupes, structure de base pour construire des expressions régulières plus pointues.</p>
<h1 id="les-groupes">Les groupes</h1>
<h2 id="les-groupes-capturant">Les groupes capturant</h2>
<p>Vous connaissez certainement déjà ces groupes, par exemple :</p>
<pre><code class="language-java">public class Groups {
    private static final String mail = &quot;brice [dot] dutheil [at] yopmail [dot] com&quot;;

    @Test
    public void grouping() {
        Matcher matcher = Pattern.compile(&quot;([a-z]+) ( ?\\[[a-z]+\\] ([a-z]+))+&quot;).matcher(mail);
        matcher.find();

        assertEquals(&quot;brice&quot;, matcher.group(1));
    }
}
</code></pre>
<p>Dans l&rsquo;expression ci-dessus, il y a trois groupes définis dans l&rsquo;expression rationnelle.</p>
<ul>
<li>
<span class="highlight-red"><code>([a-z]+)</code></span><code> ( ?\[[a-z]+\] ([a-z]+))+</code>
qui est donc le <strong>groupe 1</strong></li>
<li><code>([a-z]+) </code>
<span class="highlight-red"><code>( ?\[[a-z]+\] ([a-z]+))</code></span><code>+</code>
qui est le <strong>groupe 2</strong></li>
<li><code>([a-z]+) ( ?\[[a-z]+\] </code>
<span class="highlight-red"><code>([a-z]+)</code></span><code>)+</code>
enfin qui est le <strong>groupe 3</strong> il est défini à l&rsquo;intérieur du groupe 2</li>
</ul>
<p>Le moteur de l&rsquo;expression régulière enregistre juste la référence du groupe, et lorsque qu&rsquo;il y a récursion sur
les groupes, le groupe prend la valeur du dernier contenu matché. Ainsi dans cet exemple après un premier appel à
<code>find()</code>, l&rsquo;ensemble de la chaîne de caractère a été consommée, il est alors possible de récupérer les groupes 2 et 3
en faisant appel à <code>group()</code> :</p>
<pre><code class="language-java">assertEquals(&quot;[dot] com&quot;, matcher.group(2));
assertEquals(&quot;com&quot;, matcher.group(3));
</code></pre>
<p>En plus de ça, les références aux groupes sont limitées à 10. C&rsquo;est rare d&rsquo;avoir besoin de plus de
10 groupes, si c&rsquo;est le cas il faudra peut-être revoir l&rsquo;algorythme d&rsquo;extraction de donnée.
Par exemple splitter la chaîne ou la regex.</p>
<p>Cependant on peut en partie s&rsquo;arranger pour que les groupes qui ne nous intéressent pas ne soit pas référencés, il faut
utiliser un groupe on-capturant.</p>
<h2 id="les-groups-non-capturant-non-capturing-groups">Les groups non-capturant (non-capturing groups)</h2>
<p>C&rsquo;est presque à la fin de la javadoc de la classe <code>Pattern</code>. Ils se construisent de la manière suivante :</p>
<pre><code class="language-java">(?:regex)
</code></pre>
<p><code>?:</code> indique que ce groupe n&rsquo;est pas capturant.</p>
<p>Pour reprendre l&rsquo;exemple plus haut, le groupe 2 n&rsquo;est pas vraiment utile à notre expression régulière. Du coup
on pourrait écrire :</p>
<pre><code class="language-java">@Test
public void groupingNonCapturing() {
  Matcher matcher = Pattern.compile(&quot;([a-z]+) (?:[ ]?\\[[a-z]+\\] ([a-z]+))+&quot;).matcher(mail);
  matcher.find();

  assertEquals(&quot;brice&quot;, matcher.group(1));
  assertEquals(&quot;com&quot;, matcher.group(2));
}
</code></pre>
<p>Il n&rsquo;y a alors 2 groupes uniquement qui sont enregistré et référencé.</p>
<h1 id="les-références-arrière-backreferences">Les références arrière (backreferences)</h1>
<p>Une <strong>référence arrière</strong>, fait référence à un groupe qui a déjà été identifié et donc référencé. Typiquement
on pourra utiliser ces références arrière pour matcher exactement la même chaine que celle matchée par le groupe.</p>
<p>Ce type de construtions fait partie des avancées sur les moteurs de dernière génération.</p>
<pre><code>\X
</code></pre>
<p>Ou X est le numéro du groupe, sa référence. Par exemple le cas le plus simple :</p>
<pre><code class="language-java">assertTrue(Pattern.compile(&quot;([0-9]+) \\1&quot;)
                  .matcher(&quot;123 123&quot;)
                  .matches()); // 123 matche le groupe 1 (123)

assertFalse(Pattern.compile(&quot;([0-9]+) \\1&quot;)
                   .matcher(&quot;987 9876&quot;)
                   .matches()); // 9876 ne matche pas exactement le groupe 1 (987)
</code></pre>
<p>Première assertion; le groupe 1 matche <code>123</code>, la backreference va chercher à matcher le contenu exacte qui a
été matché par le groupe 1, donc <code>123</code>. La deuxième assertion montre bien que la backreference ne matchera pas <code>9876</code>,
car le moteur s&rsquo;attend au même contenu que <code>987</code>.
Enfin notez quand même l&rsquo;utilisation de l&rsquo;appel <code>matches()</code> plutôt que <code>find()</code>.</p>
<p>Bien entendu il faut que ce soit un groupe capturant, sinon la backreference ne sait pas ou chercher sa valeur.
L&rsquo;exemple qui suit montre un <code>Pattern</code> qui compile, mais qui ne fonctionnera pas:</p>
<pre><code class="language-java">assertTrue(Pattern.compile(&quot;(?:[0-9]+) \\1&quot;).matcher(&quot;123 123&quot;).matches()); // fail
</code></pre>
<p>Le simple fait que ce pattern compile m'étonne, j&rsquo;aurais plutôt choisi une approche <em>fail-fast</em> dans ce cas, c&rsquo;est peut-être un oubli.</p>
<p>Ce genre de construction est assez pratique si on veut vérifier un élément d&rsquo;un langage comme le XML. (Pas de le parser !)</p>
<pre><code class="language-java">assertTrue(Pattern.compile(&quot;&lt;([a-z]+)&gt;.*&lt;/\\1&gt;&quot;).matcher(&quot;**dude!**&quot;).matches()); // fail
assertTrue(Pattern.compile(&quot;&lt;([a-z]+)[^&gt;]*&gt;.*&lt;/\\1&gt;&quot;).matcher(&quot;&lt;strong style=\&quot;\&quot;&gt;dude!&lt;/strong&gt;&quot;).matches()); // ok
assertTrue(Pattern.compile(&quot;&lt;([a-z]+)[^&gt;]*&gt;.*&lt;/\\1&gt;&quot;).matcher(&quot;**dude!**&quot;).matches()); // fail
</code></pre>
<p>Attention il peut y avoir des astuces, en particulier sur le groupe qui fait le premier match. Par exemple dans
le suivant on va voir le moteur regex valider l&rsquo;expression, alors que la chaîne à valider n&rsquo;est pas correcte :</p>
<pre><code class="language-java">assertTrue(Pattern.compile(&quot;&lt;([a-z]+)[^&gt;]*&gt;.*!&lt;/\\1&gt;&quot;)
                  .matcher(&quot;&lt;strong&gt;dude!&lt;/s&gt;&quot;)
                  .matches()); // ok, wait what!
</code></pre>
<p>Effectivement <code>&lt;strong&gt;&lt;/s&gt;</code> n&rsquo;est pas correct syntaxiquement pour du XML pourtant le moteur valide la séquence de
caractère. La raison derrière c&rsquo;est qu&rsquo;il y a le mécanisme de <strong>backtracking</strong> très puissant du moteur de regex.
Avant d&rsquo;appronfondir sur le <em>backtracking</em>, il faut se rendre compte que le moteur matche correctement dans ce cas,
voilà ce qu&rsquo;il se passe :</p>
<ol>
<li>
<p>Le moteur trouve <code>strong</code> pour le <em>groupe 1</em>,</p>
</li>
<li>
<p>mais lorsqu&rsquo;il essaye de matcher la backreference avec <code>strong</code>,</p>
</li>
<li>
<p>il n&rsquo;y arrive pas donc il <em>reviens en arrière</em> pour tenter d&rsquo;autres combinaisons qui marche</p>
</li>
<li>
<p>Le moteur essaie jusqu'à trouver cette combinaison :</p>
<p>le <em>groupe 1</em> a pour valeur <code>s</code>, ce qui permet à la backreference de matcher.
Le reste du texte <code>trong</code> est alors matchée par cette partie de l&rsquo;expression <code>[^&gt;]*</code>.</p>
</li>
</ol>
<p>La solution, est d&rsquo;utiliser une borne de mot (vu dans la partie 1 de cette petite série d&rsquo;article).</p>
<pre><code class="language-java">assertFalse(Pattern.compile(&quot;&lt;([a-z]+\\b)[^&gt;]&gt;.*&lt;/\\1&gt;&quot;)
                   .matcher(&quot;&lt;strong&gt;dude!&lt;/s&gt;&quot;)
                   .matches());
</code></pre>
<p>De cette façon le <em>groupe 1</em> <code>([a-z]+\b)</code> est littéralement obligé d'être suivi par autre chose qu&rsquo;un caractère
de mot (classe <code>\w</code>). Avec cette expression la balise fermante ne peut plus être matché par la backreference.</p>
<p>Utilisation sympa des backreferences est de chercher dans un texte les mots répétés dans un texte :</p>
<pre><code class="language-java">assertTrue(Pattern.compile(&quot;\\b(\\w+)\\s+\\1\\b&quot;).matcher(&quot;the the is repeated&quot;).find());
</code></pre>
<h1 id="les-quantificateurs">Les quantificateurs</h1>
<p>Les quantificateurs permettent comme leur nom l&rsquo;indique de quantifier (une expression). À l&rsquo;exception de
l&rsquo;opérateur de Kleene, géré par les moteurs de regex depuis très longtemps, tous les autres quantificateurs
sont des représentations simplifiées de ce qui est exprimable par des constructions basiques.</p>
<ul>
<li><code>dady?</code> Le quantificateur optionnel peut s&rsquo;exprimer par une alternative (attention à l&rsquo;ordre) : <code>dady|dad</code></li>
<li><code>(?:pa){1,3}</code> Le quantificateur borné peut s&rsquo;exprimer en répétant les termes et/ou avec une alternative : <code>pa|papa|papapa</code></li>
<li><code>vrou+m</code> Le quantificateur 1 ou plus peut être remplacé par l’occurrence 1 puis par une construction avec l&rsquo;opérateur de Kleene : <code>vrouu*m</code></li>
</ul>
<p>Bref ces notations simplifiées sont bien pratiques.</p>
<h2 id="les-quantificateurs-gourmands-greedy-quantifiers">Les quantificateurs gourmands (greedy quantifiers)</h2>
<p>Pas de surprise ces quantificateurs font partie de la catégorie des quantificateurs dit gourmands. Vous savez
certainement déjà les utiliser, cependant il peut y avoir des cas qui peuvent poser problèmes.</p>
<p>Dans l&rsquo;exemple suivant je voudrais chopper la balise ouvrante.</p>
<pre><code class="language-java">public class Quantifiers {
    @Test
    public void greedy() {
        assertEquals(&quot;&lt;h1&gt;wont match&lt;/h1&gt;&quot;, regexFirstMatch(&quot;&lt;h1&gt;wont match&lt;/h1&gt;&quot;, &quot;&lt;.+&gt;&quot;)); // greediness busted
        assertEquals(&quot;&lt;h1&gt;&quot;, regexFirstMatch(&quot;&lt;h1&gt;wont match&lt;/h1&gt;&quot;, &quot;&lt;.+?&gt;&quot;));
    }

    private String regexFirstMatch(String text, String regex) {
        Matcher matcher = Pattern.compile(regex).matcher(text);

        return matcher.find() ? matcher.group(0) : &quot;didnt found match&quot;;
    }
}
</code></pre>
<p>Dans la première approche on utilise un quantificateur gourmand <code>&lt;.+&gt;</code> ce qui veut dire que le moteur va essayer de
consommer au maximum la séquence de caractères.</p>
<ol>
<li>
<p>Pour la section <code>.+</code> de la regex, le quantificateur va essayer de valider au maximum le <code>.</code></p>
<ul>
<li>Du coup le premier caractère <code>&gt;</code> est validé par la construction <code>.</code>,</li>
<li>Puis le deuxième (le dernier caractère) <code>&gt;</code> est également validé par <code>.</code>.</li>
</ul>
</li>
<li>
<p>Après ce dernier <code>&gt;</code> dans la séquence de caractère la chaîne complète est consommée, mais il reste le dernier <code>&gt;</code> <strong>dans l&rsquo;expression rationnelle</strong>.</p>
</li>
<li>
<p>Du coup le moteur utilise le mécanisme de backtracking pour revenir en arrière, il tombe alors sur le <code>1</code> de <code>&lt;/h1&gt;</code>.</p>
</li>
<li>
<p>Finalement le <code>&gt;</code> de l&rsquo;expression matche le <code>&gt;</code> de la séquence de caractère.</p>
</li>
</ol>
<p>Comme ce n&rsquo;est pas ce qu&rsquo;on veut récupérer, la balise ouvrante, une solution serait donc de prendre un
<strong>quantificateur paresseux</strong> identifiable par le point d’interrogation qui suit le quantificateur.</p>
<p>Question performance dans le cas présent, il est plus intéressant de ne pas utiliser le point <code>.</code> avec un
quantificateur paresseux mais plutôt d&rsquo;utiliser un complément de l&rsquo;ensemble qu&rsquo;on ne veut pas matcher, c&rsquo;est à dire
une classe de caractère avec exclusion du caractère non voulu <code>&gt;</code>.</p>
<pre><code class="language-java">assertEquals(&quot;&lt;h1&gt;&quot;, regexFirstMatch(&quot;&lt;h1&gt;wont match&lt;/h1&gt;&quot;, &quot;&lt;[^&gt;]+&gt;&quot;));
</code></pre>
<h2 id="les-quantificateurs-paressseux-lazy-quantifiers">Les quantificateurs paressseux (lazy quantifiers)</h2>
<p>Ces quantificateurs sont bien nommés parce dans le genre, ils vont en faire vraiment le moins possible. Pour les comparer
donc avec un quantificateur gourmand ou la séquence maximum est consommée (notez que la méthode <strong>regexFirstMatch</strong> est
la même que dans le bout de code ci-dessus) :</p>
<pre><code class="language-java">assertEquals(&quot;abc1abc2&quot;, regexFirstMatch(&quot;abc1abc2&quot;, &quot;abc1(?:abc\\d)?&quot;));
</code></pre>
<p>Le quantificateur <code>?</code> essaye de matcher la regex du groupe, et il y arrive, donc la séquence complète est consommée.
Par contre ci la regex utilise une construction avec un quantificateur paresseux <code>??</code> :</p>
<pre><code class="language-java">assertEquals(&quot;abc1&quot;, regexFirstMatch(&quot;abc1abc2&quot;, &quot;abc1(?:abc\\d)??&quot;));
</code></pre>
<p>Alors le quantificateur ne va pas s&rsquo;emmerder à matcher, si la regex matche déjà ce qui est fait par la première partie
de la regex <code>abc1</code>. Ce qu&rsquo;il faut retenir c&rsquo;est qu&rsquo;un lazy quantifier, ne matchera jamais si le moteur valide déjà
l&rsquo;expression, et le corollaire est que le lazy quantifer cherchera toujours à matcher si et uniquement si la regex
n&rsquo;a pas déjà été validée.</p>
<p>Autre exemple avec un quantificateur borné :</p>
<pre><code class="language-java">assertEquals(&quot;abc1abc2abc3&quot;, regexFirstMatch(&quot;abc1abc2abc3&quot;, &quot;(?:abc\\d){2,3}&quot;)); // greediness busted
assertEquals(&quot;abc1abc2&quot;, regexFirstMatch(&quot;abc1abc2abc3&quot;, &quot;(?:abc\\d){2,3}?&quot;)); // lazyness
assertEquals(&quot;didnt found match&quot;, regexFirstMatch(&quot;abc1&quot;, &quot;(?:abc\\d){2,3}?&quot;));
</code></pre>
<p>À la ligne 2, le quantificateur paresseux est obligé d'être exécuté une fois au moins pour matcher, mais il en fait
le moins possible.</p>
<h2 id="les-quantificateurs-possessifs-possessive-quantifiers">Les quantificateurs possessifs (possessive quantifiers)</h2>
<p>Les quantificateurs gourmands et paresseux, utilisent intelligement la capacité de backtracking afin d'évaluer
les permutations possible qui permettent de valider l&rsquo;expression régulière suivant leur stratégies respectives
(<em>en faire le plus</em> ou <em>en faire le moins</em>). Cette propriété permet d&rsquo;avoir des expressions assez souples pour
matcher un grand nombre de séquence de caractère.</p>
<p>Cependant <strong>cette souplesse a un coût, le backtracking a un coût en mémoire et en temps CPU</strong>. Ce coût monte suivant
la complexité de l&rsquo;expression rationnelle et en fonction de la séquence de caractère. Pour des raisons de performance
les créateurs des moteurs de regex ont introduit une nouvelle construction qui améliore les performances de votre
regex : les quantificateurs possessifs.</p>
<p>Cette catégorie de quantificateur est un peu différente des deux autres, dans la mesure ou le
<strong>backtracking est désactivé</strong>. Ce qui veut dire, si vous avez suivi, que l&rsquo;expression régulière ne peut pas revenir
en arrière chercher une précédente position ou la regex validait. Cependant il faut noter qu&rsquo;un possessive quantifier
cherche également à matcher le plus possible.</p>
<p>Typiquement dans le code suivant :</p>
<pre><code class="language-java">assertEquals(&quot;&lt;h1&gt;will match&lt;/h1&gt;&quot;, regexFirstMatch(&quot;&lt;h1&gt;will match&lt;/h1&gt;&amp;nbsp;&quot;, &quot;&lt;.+&gt;&quot;));
</code></pre>
<p>La partie de l&rsquo;expression régulière <code>.+</code> va tout matcher jusqu&rsquo;au point virgule <code>;</code> de <code>&amp;nbsp;</code>. Seulement comme expliqué
plus haut, une fois que la String est consommée, le caractère <code>&gt;</code> dans la regex ne peut pas matcher, donc le moteur
reviens plusieurs fois sur ses pas, puis ressaye de matcher le <code>&gt;</code> de la regex. Ce comportement peut être désiré
dans certains cas, mais parfois si on souhaite juste rechercher quelque chose de spécifique ou valider très vite
un texte sans chercher d&rsquo;autres combinaisons alors ce n&rsquo;est pas l&rsquo;idéal.</p>
<pre><code class="language-java">assertEquals(&quot;didnt found match&quot;, regexFirstMatch(&quot;&lt;h1&gt;will match&lt;/h1&gt;&amp;nbsp;&quot;, &quot;&lt;.++&gt;&quot;));
</code></pre>
<p>Ici l&rsquo;expression est constituée d&rsquo;un possessive quantifier, et en effet l&rsquo;expression ne matche pas parce
qu’une fois que la regex a consommée l&rsquo;ensemble de la chaîne, et qu&rsquo;elle ne peut plus matcher le dernier <code>&gt;</code>,
elle se déclare en erreur. On peut voir ça comme une construction du genre <em>fail-fast</em>.</p>
<p>L&rsquo;intérêt véritable des constructions de cette catégorie est intéressante uniquement si les <strong>sections adjacentes
de la regex sont mutuellement exclusives</strong>. L&rsquo;exemple le plus prégnant est lorsqu&rsquo;on utilise un complément
avec un quantificateur possessif :</p>
<pre><code class="language-java">assertFalse(Pattern.compile(&quot;&lt;[^&gt;]++&gt;&quot;).matcher(&quot;&lt;property attr1=\&quot;blah\&quot; ....&gt;&gt;&quot;).matches());
</code></pre>
<p>Ici le complément <code>[^&gt;]</code> est naturellement mutuellement exclusif avec le caractère <code>&gt;</code>, ce qui permet à la regex
d&rsquo;invalider très vite la séquence de caractères (notez la fin de la chaîne <code>&gt;&gt;</code>). Si on avait utilisé un greedy
quantifier, alors le moteur serait revenu en arrière autant de fois que possible pour tenter de valider l&rsquo;expression,
ce qui est impossible avec la séquence passée en paramètre.</p>
<p>Exemple à ne pas faire, car les tokens ne sont pas mutuellement exclusifs ; <code>a*+</code> immédiatement suivi d&rsquo;un <code>a</code>,
du coup la regex ne peut pas matcher car <code>a*+</code> consomme tous les <code>a</code> :</p>
<pre><code class="language-java">assertFalse(Pattern.matches(&quot;\\ba*+ab\\b&quot;, &quot;aaaaaaab&quot;));
</code></pre>
<p>Les quantificateurs possessifs sont des constructions qui sont supportées par les dernières générations de moteur
de regex, parce qu&rsquo;ils sont en réalité des groupes spéciaux. En effet dans la Javadoc de la classe
<a href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html">Pattern</a>, on trouve à la fin une partie
sur les constructions spéciales, et celle qui nous intéresse dans ce cas, c&rsquo;est celle là :</p>
<blockquote>
<p><code>(?&gt;X)</code> X, as an <strong>independent, non-capturing group</strong></p>
</blockquote>
<ol>
<li><em>&ldquo;non capturing&rdquo;</em> : Simplement parce que le groupe ne fait pas de capture lorsque X matche.</li>
<li><em>&ldquo;independant&rdquo;</em> : Ici ce n&rsquo;est pas très clair dans la javadoc de Pattern, pour trouver la signification
il faut se rendre sur la <a href="http://perldoc.perl.org/perlretut.html">documentation des regex en Perl</a>, on y apprend
qu&rsquo;il s&rsquo;agit d&rsquo;un groupe indépendant du reste de l&rsquo;expression régulière, que ce groupe ne sait pas revenir
en arrière (pas de backtracking), en gros le moteur de regex permet à ce groupe de consommer tout ce qu&rsquo;il peut
sans considérer les autres parties de la regex.</li>
</ol>
<p>Une petite vérification :</p>
<pre><code class="language-java">assertTrue(Pattern.matches(&quot;\\ba*+b\\b&quot;, &quot;aaaaaaab&quot;));
assertFalse(Pattern.matches(&quot;\\ba*+b\\b&quot;, &quot;aaaaaaa&quot;));

assertTrue(Pattern.matches(&quot;\\b(?&gt;a*)b\\b&quot;, &quot;aaaaaaab&quot;));
assertFalse(Pattern.matches(&quot;\\b(?&gt;a*)b\\b&quot;, &quot;aaaaaaa&quot;));
</code></pre>
<p>Donc un quantificateur possessif est une notation simplifiée d&rsquo;un groupe indépendant et non capturant!</p>
<h1 id="le-backtracking-1">Le backtracking</h1>
<p>Comme vous le savez, je l&rsquo;ai bien répété, le backtracking c&rsquo;est ce qui permet au moteur de regex de traquer
les constructions qui ont validé. Le backtracking n&rsquo;a de sens que pour les quantificateurs, en effet ce sont
les quantificateurs qui vont essayer de tester une construction un certain nombre de fois. Cela dit cette
construction peut-être suvi par une autre et le moteur doit s&rsquo;assurer que les constructions qui suivent
le quantificateur valident également le reste de la séquence.</p>
<h2 id="prenons-un-exemple-">Prenons un exemple :</h2>
<p>Dans le cas suivant on le pattern, observez le fait que le point <code>.</code> n&rsquo;est pas mutuellement exclusif avec <code>bob</code>.</p>
<pre><code>ab.*bob
</code></pre>
<p>Et on essaye de valider la chaine de caractères, les chiffres sont là pour illustrer la partie sur la quelle
la construction <code>.*</code> devrait matcher, mais des lettres auraient pu faire l&rsquo;affaire.</p>
<pre><code>ab1234bob
</code></pre>
<p>A la première étape <code>Pattern.compile</code>, l&rsquo;expression va être transformée dans un arbre. Techniquement le code
ressemble à la fois au pattern <em>Chain of Responsability</em> et au pattern <em>Composite</em> (pour les groupes ou pour les
quantificateurs notamment). Le moteur ajoute ses propres nœud au début et à la fin de l&rsquo;arbre pour travailler avec
cette représentation.</p>
<p>Dans le diagramme suivant chaque cadre correspond à l'état de la consommation de la séquence de caractère et à
celui de l&rsquo;expression régulière ainsi découpée en nœuds.</p>
<p><img src="/assets/backtracking.png" alt="backtracking"></p>
<p>On comprend immédiatement le problèmes potentiels sur des expressions qui utilisent énormément les quantificateurs non-possessifs :</p>
<ol>
<li>Plus la partie à matchée est longue pour le quantificateur, plus la mémoire sera consommée.</li>
<li>Si les constructions qui suivent ne matchent pas, celles-ci devront être annulée et réessayée, ce qui veut dire un temps d’exécution plus long!</li>
</ol>
<p>La solution c&rsquo;est de faire attention quand on construit une expression rationnelle. En particulier si elle est critique,
l&rsquo;idée serait de la benchmarquée, mais bon il faut pas tomber non plus dans ce qu&rsquo;on appelle <strong>Premature Optimisation</strong>.</p>
<h1 id="bilan">Bilan</h1>
<p>Le backtracking c&rsquo;est bien ; c&rsquo;est ce qui permet à la regex d'être souple, mais clairement il faut faire attention à
ce mécanisme. Il sera intéressant du coup d&rsquo;utiliser des groupes non-capturants et indépendants si l&rsquo;opportunité le permet.</p>
<p>Cette série s&rsquo;achèvera par une troisième et dernière partie ou j&rsquo;aborderaie les possibilité de travailler avec Unicode,
et surtout comment indiquer dans une regex qu&rsquo;on ne veut pas d&rsquo;une construction complète.</p>
<h1 id="références">Références</h1>
<ul>
<li><a href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html">http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html</a></li>
<li><a href="http://perldoc.perl.org/perlretut.html">http://perldoc.perl.org/perlretut.html</a></li>
</ul>

  </div>
  

<div class="navigation navigation-single">
    
    <a href="/2010/09/27/sexprimer-regulierement-partie-1/" class="navigation-prev">
      <i aria-hidden="true" class="fa fa-chevron-left"></i>
      <span class="navigation-tittle">Expressions régulières (Partie 1)</span>
    </a>
    
    
    <a href="/2010/11/04/sexprimer-regulierement-partie-3/" class="navigation-next">
      <span class="navigation-tittle">Expressions régulières (Partie 3)</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  

  <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
        
        
        
        this.page.identifier = '211 http:\/\/dutheil.brice.online.fr\/blog\/?p=211';
        this.page.title = 'Expressions régulières (Partie 2)';
        this.page.url = 'https://blog.arkey.fr/2010/10/15/sexprimer-regulierement-partie-2/';
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "thecoffeeworkshop" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</article>


        </div>
        
    










<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin="anonymous"></script><script type="text/javascript">
        
        hljs.initHighlightingOnLoad();
    </script>
    
    


<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js" integrity="sha256-vrn14y7WH7zgEElyQqm2uCGSQrX/xjYDjniRUQx3NyU=" crossorigin="anonymous"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

function globalSwitch() {
	$('.switch--item').each(function() {
		var blockId = blockIdForSwitchItem($(this));
		$(this).off('click');
		$(this).on('click', function() {
			selectedText = $(this).text()
			window.localStorage.setItem(blockId, selectedText);
			$(".switch--item").filter(function() {
				return blockIdForSwitchItem($(this)) === blockId;
			}).filter(function() {
				return $(this).text() === selectedText;
			}).each(function() {
				select($(this))
			});
		});
		if ($(this).text() === window.localStorage.getItem(blockId)) {
			select($(this))
		}
	});
}

function blockIdForSwitchItem(item) {
	idComponents = []
	idComponents.push(item.text().toLowerCase());
	item.siblings(".switch--item").each(function(index, sibling) {
		idComponents.push($(sibling).text().toLowerCase());
	});
	return idComponents.sort().join("-")
}

function select(selected) {
	selected.addClass('selected');
	selected.siblings().removeClass('selected');
	selectedContent = selected.parent().siblings(".content").eq(selected.index())
	selectedContent.removeClass('hidden');
	selectedContent.siblings().addClass('hidden');
}

$(addBlockSwitches);
$(globalSwitch);
</script>


    



    </body>
</html>
